SNAT conntrack implementation

流程函数即注册在worker框架下的一系列钩子函数，它们实现了natgw的主体功能，主要包括：
QoS：igw_qos_run
连接状态跟踪： conntrack_in	conntrack_confirm
SNAT/DNAT：	igw_nat_run
VPC路由查找：	igw_route_run


void conntrack_init(void)
{
	int tid;

	/* hash bucket size is CT_SESSION_MAX/2. so session must be power of 2 */
	//BUILD_BUG_ON((CT_SESSION_MAX & (CT_SESSION_MAX - 1)) != 0);

	PAL_FOR_EACH_WORKER(tid) {
		pal_remote_launch(ct_table_init, NULL, tid);
		pal_wait_thread(tid);
	}

	if (pal_cleanup_register("conntrack_cleanup", conntrack_cleanup, PIPELINE_PRIORITY_CT_IN, NULL) < 0)
		PAL_PANIC("conntrack: register pipeline function failed\n");

	if (pal_pipeline_register("conntrack_in", conntrack_in, PIPELINE_PRIORITY_CT_IN, NULL) < 0)
		PAL_PANIC("conntrack: register pipeline function failed\n");

	if (pal_pipeline_register("conntrack_confirm", conntrack_confirm, PIPELINE_PRIORITY_CT_CONFIRM, NULL) < 0)
		PAL_PANIC("conntrack: register pipeline function failed\n");

    if (ct_sync_init()) {
		PAL_PANIC("conntrack: ct_sync_init failed\n");
	}
	
	return;
}

DPDK是创建N个线程，每个线程在一个CPU上跑，每个CPU上有一个per cpu变量来保存session。

内核版本不能这样，需要参考内核中对于流表的访问方式。

    /* Check if this is a duplicate flow */
    if (ovs_identifier_is_ufid(&new_flow->id))
        flow = ovs_flow_tbl_lookup_ufid(&dp->table, &new_flow->id);
    if (!flow)
        flow = ovs_flow_tbl_lookup(&dp->table, &new_flow->key); //查找当前的流表table中是否已经有这条流表
    if (likely(!flow)) {
        rcu_assign_pointer(new_flow->sf_acts, acts);//更新这条流表的actions

        /* Put flow in bucket. */
        error = ovs_flow_tbl_insert(&dp->table, new_flow, &mask);//将流表加入到流表table中
        if (unlikely(error)) {
            acts = NULL;
            goto err_unlock_ovs;
        }

        if (unlikely(reply)) {
            error = ovs_flow_cmd_fill_info(new_flow,
                               ovs_header->dp_ifindex,
                               reply, info->snd_portid,
                               info->snd_seq, 0,
                               OVS_FLOW_CMD_NEW,
                               ufid_flags);
            BUG_ON(error < 0);
        }
        ovs_unlock();
    } 

查找是否存在，如果不存在则插入，这里如何保护这个共享的数据结构？

我们先来分析一下ovs在内核对于session的实现

 (flow #1)
 $ ovs-ofctl add-flow br0 \
    "table=0, priority=50, ct_state=-trk, tcp, in_port=veth_l0, actions=ct(table=0)"

(flow #2)
$ ovs-ofctl add-flow br0 \
    "table=0, priority=50, ct_state=+trk+new, tcp, in_port=veth_l0, actions=ct(commit),veth_r0"

(flow #3)
$ ovs-ofctl add-flow br0 \
    "table=0, priority=50, ct_state=-trk, tcp, in_port=veth_r0, actions=ct(table=0)"

(flow #4)
$ ovs-ofctl add-flow br0 \
    "table=0, priority=50, ct_state=+trk+est, tcp, in_port=veth_r0, actions=veth_l0"

(flow #5)
$ ovs-ofctl add-flow br0 \
"table=0, priority=50, ct_state=+trk+est, tcp, in_port=veth_l0, actions=veth_r0"

static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,
			      struct sw_flow_key *key,
			      const struct nlattr *attr, int len)

		case OVS_ACTION_ATTR_CT:
			if (!is_flow_key_valid(key)) {
				err = ovs_flow_key_update(skb, key);
				if (err)
					return err;
			}

			err = ovs_ct_execute(ovs_dp_get_net(dp), skb, key,
					     nla_data(a));

			/* Hide stolen IP fragments from user space. */
			if (err)
				return err == -EINPROGRESS ? 0 : err;
			break;

		case OVS_ACTION_ATTR_CT_CLEAR:
			err = ovs_ct_clear(skb, key);
			break;

/* Conntrack action context for execution. */
struct ovs_conntrack_info {
	struct nf_conntrack_helper *helper;
	struct nf_conntrack_zone zone;
	struct nf_conn *ct;
	u8 commit : 1;
	u8 nat : 3;                 /* enum ovs_ct_nat */
	u8 random_fully_compat : 1; /* bool */
	u8 force : 1;
	u8 have_eventmask : 1;
	u16 family;
	u32 eventmask;              /* Mask of 1 << IPCT_*. */
	struct md_mark mark;
	struct md_labels labels;
	char timeout[CTNL_TIMEOUT_NAME_MAX];
	struct nf_ct_timeout *nf_ct_timeout;
#if IS_ENABLED(CONFIG_NF_NAT_NEEDED)
	struct nf_nat_range2 range;  /* Only present for SRC NAT and DST NAT. */
#endif
};

static int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,
                  const struct sw_flow_key *key,
                  struct sw_flow_actions **sfa,
                  __be16 eth_type, __be16 vlan_tci,
                  u32 mpls_label_count, bool log)
        case OVS_ACTION_ATTR_CT:
            err = ovs_ct_copy_action(net, a, key, sfa, log);
            if (err)
                return err;
            skip_copy = true;
            break;

        case OVS_ACTION_ATTR_CT_CLEAR:
            break;

int ovs_ct_copy_action(struct net *net, const struct nlattr *attr,
		       const struct sw_flow_key *key,
		       struct sw_flow_actions **sfa,  bool log)
{
	struct ovs_conntrack_info ct_info;
	const char *helper = NULL;
	u16 family;
	int err;

	family = key_to_nfproto(key);
	if (family == NFPROTO_UNSPEC) {
		OVS_NLERR(log, "ct family unspecified");
		return -EINVAL;
	}

	memset(&ct_info, 0, sizeof(ct_info));
	ct_info.family = family;

	nf_ct_zone_init(&ct_info.zone, NF_CT_DEFAULT_ZONE_ID,
			NF_CT_DEFAULT_ZONE_DIR, 0);

	err = parse_ct(attr, &ct_info, &helper, log);
	if (err)
		return err;

	/* Set up template for tracking connections in specific zones. */
	ct_info.ct = nf_ct_tmpl_alloc(net, &ct_info.zone, GFP_KERNEL);
	if (!ct_info.ct) {
		OVS_NLERR(log, "Failed to allocate conntrack template");
		return -ENOMEM;
	}

	if (ct_info.timeout[0]) {
		if (nf_ct_set_timeout(net, ct_info.ct, family, key->ip.proto,
				      ct_info.timeout))
			pr_info_ratelimited("Failed to associated timeout "
					    "policy `%s'\n", ct_info.timeout);
		else
			ct_info.nf_ct_timeout = rcu_dereference(
				nf_ct_timeout_find(ct_info.ct)->timeout);

	}

	if (helper) {
		err = ovs_ct_add_helper(&ct_info, helper, key, log);
		if (err)
			goto err_free_ct;
	}

	err = ovs_nla_add_action(sfa, OVS_ACTION_ATTR_CT, &ct_info,
				 sizeof(ct_info), log);
	if (err)
		goto err_free_ct;

	__set_bit(IPS_CONFIRMED_BIT, &ct_info.ct->status);
	nf_conntrack_get(&ct_info.ct->ct_general);
	return 0;
err_free_ct:
	__ovs_ct_free_action(&ct_info);
	return err;
}

static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,
		    const char **helper, bool log)
{
	struct nlattr *a;
	int rem;

	nla_for_each_nested(a, attr, rem) {
		int type = nla_type(a);
		int maxlen;
		int minlen;

		if (type > OVS_CT_ATTR_MAX) {
			OVS_NLERR(log,
				  "Unknown conntrack attr (type=%d, max=%d)",
				  type, OVS_CT_ATTR_MAX);
			return -EINVAL;
		}

		maxlen = ovs_ct_attr_lens[type].maxlen;
		minlen = ovs_ct_attr_lens[type].minlen;
		if (nla_len(a) < minlen || nla_len(a) > maxlen) {
			OVS_NLERR(log,
				  "Conntrack attr type has unexpected length (type=%d, length=%d, expected=%d)",
				  type, nla_len(a), maxlen);
			return -EINVAL;
		}

		switch (type) {
		case OVS_CT_ATTR_FORCE_COMMIT:
			info->force = true;
			/* fall through. */
		case OVS_CT_ATTR_COMMIT:
			info->commit = true;
			break;
#ifdef CONFIG_NF_CONNTRACK_ZONES
		case OVS_CT_ATTR_ZONE:
			info->zone.id = nla_get_u16(a);
			break;
#endif
#ifdef CONFIG_NF_CONNTRACK_MARK
		case OVS_CT_ATTR_MARK: {
			struct md_mark *mark = nla_data(a);

			if (!mark->mask) {
				OVS_NLERR(log, "ct_mark mask cannot be 0");
				return -EINVAL;
			}
			info->mark = *mark;
			break;
		}
#endif
#ifdef CONFIG_NF_CONNTRACK_LABELS
		case OVS_CT_ATTR_LABELS: {
			struct md_labels *labels = nla_data(a);

			if (!labels_nonzero(&labels->mask)) {
				OVS_NLERR(log, "ct_labels mask cannot be 0");
				return -EINVAL;
			}
			info->labels = *labels;
			break;
		}
#endif
		case OVS_CT_ATTR_HELPER:
			*helper = nla_data(a);
			if (!memchr(*helper, '\0', nla_len(a))) {
				OVS_NLERR(log, "Invalid conntrack helper");
				return -EINVAL;
			}
			break;
#if IS_ENABLED(CONFIG_NF_NAT_NEEDED)
		case OVS_CT_ATTR_NAT: {
			int err = parse_nat(a, info, log);

			if (err)
				return err;
			break;
		}
#endif
		case OVS_CT_ATTR_EVENTMASK:
			info->have_eventmask = true;
			info->eventmask = nla_get_u32(a);
			break;
#ifdef CONFIG_NF_CONNTRACK_TIMEOUT
		case OVS_CT_ATTR_TIMEOUT:
			memcpy(info->timeout, nla_data(a), nla_len(a));
			if (!memchr(info->timeout, '\0', nla_len(a))) {
				OVS_NLERR(log, "Invalid conntrack timeout");
				return -EINVAL;
			}
			break;
#endif

		default:
			OVS_NLERR(log, "Unknown conntrack attr (%d)",
				  type);
			return -EINVAL;
		}
	}

#ifdef CONFIG_NF_CONNTRACK_MARK
	if (!info->commit && info->mark.mask) {
		OVS_NLERR(log,
			  "Setting conntrack mark requires 'commit' flag.");
		return -EINVAL;
	}
#endif
#ifdef CONFIG_NF_CONNTRACK_LABELS
	if (!info->commit && labels_nonzero(&info->labels.mask)) {
		OVS_NLERR(log,
			  "Setting conntrack labels requires 'commit' flag.");
		return -EINVAL;
	}
#endif
	if (rem > 0) {
		OVS_NLERR(log, "Conntrack attr has %d unknown bytes", rem);
		return -EINVAL;
	}

	return 0;
}

/* Returns 0 on success, -EINPROGRESS if 'skb' is stolen, or other nonzero
 * value if 'skb' is freed.
 */
int ovs_ct_execute(struct net *net, struct sk_buff *skb,
		   struct sw_flow_key *key,
		   const struct ovs_conntrack_info *info)
{
	int nh_ofs;
	int err;

	/* The conntrack module expects to be working at L3. */
	nh_ofs = skb_network_offset(skb);
	skb_pull_rcsum(skb, nh_ofs);

	err = ovs_skb_network_trim(skb);
	if (err)
		return err;

	if (key->ip.frag != OVS_FRAG_TYPE_NONE) {
		err = handle_fragments(net, key, info->zone.id, skb);
		if (err)
			return err;
	}

	if (info->commit)
		err = ovs_ct_commit(net, key, info, skb);
	else
		err = ovs_ct_lookup(net, key, info, skb);

	skb_push(skb, nh_ofs);
	skb_postpush_rcsum(skb, skb->data, nh_ofs);
	if (err)
		kfree_skb(skb);
	return err;
}

/* Lookup connection and read fields into key. */
static int ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
			 const struct ovs_conntrack_info *info,
			 struct sk_buff *skb)
{
	struct nf_conntrack_expect *exp;

	/* If we pass an expected packet through nf_conntrack_in() the
	 * expectation is typically removed, but the packet could still be
	 * lost in upcall processing.  To prevent this from happening we
	 * perform an explicit expectation lookup.  Expected connections are
	 * always new, and will be passed through conntrack only when they are
	 * committed, as it is OK to remove the expectation at that time.
	 */
	exp = ovs_ct_expect_find(net, &info->zone, info->family, skb);
	if (exp) {
		u8 state;

		/* NOTE: New connections are NATted and Helped only when
		 * committed, so we are not calling into NAT here.
		 */
		state = OVS_CS_F_TRACKED | OVS_CS_F_NEW | OVS_CS_F_RELATED;
		__ovs_ct_update_key(key, state, &info->zone, exp->master);
	} else {
		struct nf_conn *ct;
		int err;

		err = __ovs_ct_lookup(net, key, info, skb);
		if (err)
			return err;

		ct = (struct nf_conn *)skb_nfct(skb);
		if (ct)
			nf_ct_deliver_cached_events(ct);
	}

	return 0;
}

/* Lookup connection and confirm if unconfirmed. */
static int ovs_ct_commit(struct net *net, struct sw_flow_key *key,
			 const struct ovs_conntrack_info *info,
			 struct sk_buff *skb)
{
	enum ip_conntrack_info ctinfo;
	struct nf_conn *ct;
	int err;

	err = __ovs_ct_lookup(net, key, info, skb);
	if (err)
		return err;

	/* The connection could be invalid, in which case this is a no-op.*/
	/* 
		这里使用的是netfilter内核的能力
		include/net/netfilter/nf_conntrack.h 

		/* Return conntrack_info and tuple hash for given skb. */
		static inline struct nf_conn *
		nf_ct_get(const struct sk_buff *skb, enum ip_conntrack_info *ctinfo)
		{
			unsigned long nfct = skb_get_nfct(skb);

			*ctinfo = nfct & NFCT_INFOMASK;
			return (struct nf_conn *)(nfct & NFCT_PTRMASK);
		}
	*/
	ct = nf_ct_get(skb, &ctinfo);
	if (!ct)
		return 0;

#if	IS_ENABLED(CONFIG_NETFILTER_CONNCOUNT)
	if (static_branch_unlikely(&ovs_ct_limit_enabled)) {
		if (!nf_ct_is_confirmed(ct)) {
			err = ovs_ct_check_limit(net, info,
				&ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple);
			if (err) {
				net_warn_ratelimited("openvswitch: zone: %u "
					"exceeds conntrack limit\n",
					info->zone.id);
				return err;
			}
		}
	}
#endif

	/* Set the conntrack event mask if given.  NEW and DELETE events have
	 * their own groups, but the NFNLGRP_CONNTRACK_UPDATE group listener
	 * typically would receive many kinds of updates.  Setting the event
	 * mask allows those events to be filtered.  The set event mask will
	 * remain in effect for the lifetime of the connection unless changed
	 * by a further CT action with both the commit flag and the eventmask
	 * option. */
	if (info->have_eventmask) {
		struct nf_conntrack_ecache *cache = nf_ct_ecache_find(ct);

		if (cache)
			cache->ctmask = info->eventmask;
	}

	/* Apply changes before confirming the connection so that the initial
	 * conntrack NEW netlink event carries the values given in the CT
	 * action.
	 */
	if (info->mark.mask) {
		err = ovs_ct_set_mark(ct, key, info->mark.value,
				      info->mark.mask);
		if (err)
			return err;
	}
	/*
		这里使用的是netfilter内核的能力
		include/net/netfilter/nf_conntrack.h 
		/* It's confirmed if it is, or has been in the hash table. */
		static inline int nf_ct_is_confirmed(const struct nf_conn *ct)
		{
			return test_bit(IPS_CONFIRMED_BIT, &ct->status);
		}
	*/
	if (!nf_ct_is_confirmed(ct)) {
		err = ovs_ct_init_labels(ct, key, &info->labels.value,
					 &info->labels.mask);
		if (err)
			return err;
	} else if (IS_ENABLED(CONFIG_NF_CONNTRACK_LABELS) &&
		   labels_nonzero(&info->labels.mask)) {
		err = ovs_ct_set_labels(ct, key, &info->labels.value,
					&info->labels.mask);
		if (err)
			return err;
	}
	/* This will take care of sending queued events even if the connection
	 * is already confirmed.
	 */
	/*
		这里使用的是netfilter内核的能力
		include/net/netfilter/nf_conntrack_core.h
		/* Confirm a connection: returns NF_DROP if packet must be dropped. */
		static inline int nf_conntrack_confirm(struct sk_buff *skb)
		{
			struct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);
			int ret = NF_ACCEPT;

			if (ct) {
				if (!nf_ct_is_confirmed(ct))
					ret = __nf_conntrack_confirm(skb);
				if (likely(ret == NF_ACCEPT))
					nf_ct_deliver_cached_events(ct);
			}
			return ret;
		}
	*/
	if (nf_conntrack_confirm(skb) != NF_ACCEPT)
		return -EINVAL;

	return 0;
}


/* Pass 'skb' through conntrack in 'net', using zone configured in 'info', if
 * not done already.  Update key with new CT state after passing the packet
 * through conntrack.
 * Note that if the packet is deemed invalid by conntrack, skb->_nfct will be
 * set to NULL and 0 will be returned.
 */
static int __ovs_ct_lookup(struct net *net, struct sw_flow_key *key,
			   const struct ovs_conntrack_info *info,
			   struct sk_buff *skb)
{
	/* If we are recirculating packets to match on conntrack fields and
	 * committing with a separate conntrack action,  then we don't need to
	 * actually run the packet through conntrack twice unless it's for a
	 * different zone.
	 */
	bool cached = skb_nfct_cached(net, key, info, skb);
	enum ip_conntrack_info ctinfo;
	struct nf_conn *ct;

	if (!cached) {
		struct nf_hook_state state = {
			.hook = NF_INET_PRE_ROUTING,
			.pf = info->family,
			.net = net,
		};
		struct nf_conn *tmpl = info->ct;
		int err;

		/* Associate skb with specified zone. */
		if (tmpl) {
			if (skb_nfct(skb))
				nf_conntrack_put(skb_nfct(skb));
			nf_conntrack_get(&tmpl->ct_general);
			nf_ct_set(skb, tmpl, IP_CT_NEW);
		}

		err = nf_conntrack_in(skb, &state);
		if (err != NF_ACCEPT)
			return -ENOENT;

		/* Clear CT state NAT flags to mark that we have not yet done
		 * NAT after the nf_conntrack_in() call.  We can actually clear
		 * the whole state, as it will be re-initialized below.
		 */
		key->ct_state = 0;

		/* Update the key, but keep the NAT flags. */
		ovs_ct_update_key(skb, info, key, true, true);
	}

	ct = nf_ct_get(skb, &ctinfo);
	if (ct) {
		bool add_helper = false;

		/* Packets starting a new connection must be NATted before the
		 * helper, so that the helper knows about the NAT.  We enforce
		 * this by delaying both NAT and helper calls for unconfirmed
		 * connections until the committing CT action.  For later
		 * packets NAT and Helper may be called in either order.
		 *
		 * NAT will be done only if the CT action has NAT, and only
		 * once per packet (per zone), as guarded by the NAT bits in
		 * the key->ct_state.
		 */
		if (info->nat && !(key->ct_state & OVS_CS_F_NAT_MASK) &&
		    (nf_ct_is_confirmed(ct) || info->commit) &&
		    ovs_ct_nat(net, key, info, skb, ct, ctinfo) != NF_ACCEPT) {
			return -EINVAL;
		}

		/* Userspace may decide to perform a ct lookup without a helper
		 * specified followed by a (recirculate and) commit with one,
		 * or attach a helper in a later commit.  Therefore, for
		 * connections which we will commit, we may need to attach
		 * the helper here.
		 */
		if (info->commit && info->helper && !nfct_help(ct)) {
			int err = __nf_ct_try_assign_helper(ct, info->ct,
							    GFP_ATOMIC);
			if (err)
				return err;
			add_helper = true;

			/* helper installed, add seqadj if NAT is required */
			if (info->nat && !nfct_seqadj(ct)) {
				if (!nfct_seqadj_ext_add(ct))
					return -EINVAL;
			}
		}

		/* Call the helper only if:
		 * - nf_conntrack_in() was executed above ("!cached") or a
		 *   helper was just attached ("add_helper") for a confirmed
		 *   connection, or
		 * - When committing an unconfirmed connection.
		 */
		if ((nf_ct_is_confirmed(ct) ? !cached || add_helper :
					      info->commit) &&
		    ovs_ct_helper(skb, info->family) != NF_ACCEPT) {
			return -EINVAL;
		}
	}

	return 0;
}

/* Initialize labels for a new, yet to be committed conntrack entry.  Note that
 * since the new connection is not yet confirmed, and thus no-one else has
 * access to it's labels, we simply write them over.
 */
static int ovs_ct_init_labels(struct nf_conn *ct, struct sw_flow_key *key,
			      const struct ovs_key_ct_labels *labels,
			      const struct ovs_key_ct_labels *mask)
{
	struct nf_conn_labels *cl, *master_cl;
	bool have_mask = labels_nonzero(mask);

	/* Inherit master's labels to the related connection? */
	master_cl = ct->master ? nf_ct_labels_find(ct->master) : NULL;

	if (!master_cl && !have_mask)
		return 0;   /* Nothing to do. */

	cl = ovs_ct_get_conn_labels(ct);
	if (!cl)
		return -ENOSPC;

	/* Inherit the master's labels, if any.  Must use memcpy for backport
	 * as struct assignment only copies the length field in older
	 * kernels.
	 */
	if (master_cl)
		memcpy(cl->bits, master_cl->bits, OVS_CT_LABELS_LEN);

	if (have_mask) {
		u32 *dst = (u32 *)cl->bits;
		int i;

		for (i = 0; i < OVS_CT_LABELS_LEN_32; i++)
			dst[i] = (dst[i] & ~mask->ct_labels_32[i]) |
				(labels->ct_labels_32[i]
				 & mask->ct_labels_32[i]);
	}

	/* Labels are included in the IPCTNL_MSG_CT_NEW event only if the
	 * IPCT_LABEL bit is set in the event cache.
	 */
	nf_conntrack_event_cache(IPCT_LABEL, ct);

	memcpy(&key->ct.labels, cl->bits, OVS_CT_LABELS_LEN);

	return 0;
}

从这里可以看出，ovs内核对于session的存储用的就是netfilter

接下来我们来看清理线程如何做的

创建datapath时，会启动专门的线程 clean_thread_main 清除超期的conntrack表项，这里是清理DPDK模式的用户态的表项的

////////////////////lib\conntrack.c

static int
create_dp_netdev(const char *name, const struct dpif_class *class,
                 struct dp_netdev **dpp)
    OVS_REQUIRES(dp_netdev_mutex)
{
    static struct ovsthread_once tsc_freq_check = OVSTHREAD_ONCE_INITIALIZER;
    struct dp_netdev *dp;
    int error;

    /* Avoid estimating TSC frequency for dummy datapath to not slow down
     * unit tests. */
    if (!dpif_netdev_class_is_dummy(class)
        && ovsthread_once_start(&tsc_freq_check)) {
        pmd_perf_estimate_tsc_frequency();
        ovsthread_once_done(&tsc_freq_check);
    }

    dp = xzalloc(sizeof *dp);
    shash_add(&dp_netdevs, name, dp);

    *CONST_CAST(const struct dpif_class **, &dp->class) = class;
    *CONST_CAST(const char **, &dp->name) = xstrdup(name);
    ovs_refcount_init(&dp->ref_cnt);
    atomic_flag_clear(&dp->destroyed);

    ovs_mutex_init_recursive(&dp->port_mutex);
    hmap_init(&dp->ports);
    dp->port_seq = seq_create();
    ovs_mutex_init(&dp->bond_mutex);
    cmap_init(&dp->tx_bonds);

    fat_rwlock_init(&dp->upcall_rwlock);

    dp->reconfigure_seq = seq_create();
    dp->last_reconfigure_seq = seq_read(dp->reconfigure_seq);

    for (int i = 0; i < N_METER_LOCKS; ++i) {
        ovs_mutex_init_adaptive(&dp->meter_locks[i]);
    }

    /* Disable upcalls by default. */
    dp_netdev_disable_upcall(dp);
    dp->upcall_aux = NULL;
    dp->upcall_cb = NULL;

    dp->conntrack = conntrack_init();

    atomic_init(&dp->emc_insert_min, DEFAULT_EM_FLOW_INSERT_MIN);
    atomic_init(&dp->tx_flush_interval, DEFAULT_TX_FLUSH_INTERVAL);

    cmap_init(&dp->poll_threads);
    dp->pmd_rxq_assign_cyc = true;

    ovs_mutex_init(&dp->tx_qid_pool_mutex);
    /* We need 1 Tx queue for each possible core + 1 for non-PMD threads. */
    dp->tx_qid_pool = id_pool_create(0, ovs_numa_get_n_cores() + 1);

    ovs_mutex_init_recursive(&dp->non_pmd_mutex);
    ovsthread_key_create(&dp->per_pmd_key, NULL);

    ovs_mutex_lock(&dp->port_mutex);
    /* non-PMD will be created before all other threads and will
     * allocate static_tx_qid = 0. */
    dp_netdev_set_nonpmd(dp);

    error = do_add_port(dp, name, dpif_netdev_port_open_type(dp->class,
                                                             "internal"),
                        ODPP_LOCAL);
    ovs_mutex_unlock(&dp->port_mutex);
    if (error) {
        dp_netdev_free(dp);
        return error;
    }

    dp->last_tnl_conf_seq = seq_read(tnl_conf_seq);
    *dpp = dp;
    return 0;
}

/* Initializes the connection tracker 'ct'.  The caller is responsible for
 * calling 'conntrack_destroy()', when the instance is not needed anymore */
struct conntrack *
conntrack_init(void)
{
    struct conntrack *ct = xzalloc(sizeof *ct);

    ovs_rwlock_init(&ct->resources_lock);
    ovs_rwlock_wrlock(&ct->resources_lock);
    hmap_init(&ct->alg_expectations);
    hindex_init(&ct->alg_expectation_refs);
    ovs_rwlock_unlock(&ct->resources_lock);

    ovs_mutex_init_adaptive(&ct->ct_lock);
    ovs_mutex_lock(&ct->ct_lock);
    cmap_init(&ct->conns);
    for (unsigned i = 0; i < ARRAY_SIZE(ct->exp_lists); i++) {
        ovs_list_init(&ct->exp_lists[i]);
    }
    hmap_init(&ct->zone_limits);
    ct->zone_limit_seq = 0;
    timeout_policy_init(ct);
    ovs_mutex_unlock(&ct->ct_lock);

    ct->hash_basis = random_uint32();
    atomic_count_init(&ct->n_conn, 0);
    atomic_init(&ct->n_conn_limit, DEFAULT_N_CONN_LIMIT);
    atomic_init(&ct->tcp_seq_chk, true);
    latch_init(&ct->clean_thread_exit);
    ct->clean_thread = ovs_thread_create("ct_clean", clean_thread_main, ct);
    ct->ipf = ipf_init();

    return ct;
}

struct conntrack {
    struct ovs_mutex ct_lock; /* Protects 2 following fields. */
    struct cmap conns OVS_GUARDED;
    struct ovs_list exp_lists[N_CT_TM] OVS_GUARDED;
    struct hmap zone_limits OVS_GUARDED;
    struct hmap timeout_policies OVS_GUARDED;
    uint32_t hash_basis; /* Salt for hashing a connection key. */
    pthread_t clean_thread; /* Periodically cleans up connection tracker. */
    struct latch clean_thread_exit; /* To destroy the 'clean_thread'. */

    /* Counting connections. */
    atomic_count n_conn; /* Number of connections currently tracked. */
    atomic_uint n_conn_limit; /* Max connections tracked. */

    /* Expectations for application level gateways (created by control
     * connections to help create data connections, e.g. for FTP). */
    struct ovs_rwlock resources_lock; /* Protects fields below. */
    struct hmap alg_expectations OVS_GUARDED; /* Holds struct
                                               * alg_exp_nodes. */
    struct hindex alg_expectation_refs OVS_GUARDED; /* For lookup from
                                                     * control context.  */

    struct ipf *ipf; /* Fragmentation handling context. */
    uint32_t zone_limit_seq; /* Used to disambiguate zone limit counts. */
    atomic_bool tcp_seq_chk; /* Check TCP sequence numbers. */
};


/* Cleanup:
 *
 * We must call conntrack_clean() periodically.  conntrack_clean() return
 * value gives an hint on when the next cleanup must be done (either because
 * there is an actual connection that expires, or because a new connection
 * might be created with the minimum timeout).
 *
 * The logic below has two goals:
 *
 * - We want to reduce the number of wakeups and batch connection cleanup
 *   when the load is not very high.  CT_CLEAN_INTERVAL ensures that if we
 *   are coping with the current cleanup tasks, then we wait at least
 *   5 seconds to do further cleanup.
 *
 * - We don't want to keep the map locked too long, as we might prevent
 *   traffic from flowing.  CT_CLEAN_MIN_INTERVAL ensures that if cleanup is
 *   behind, there is at least some 200ms blocks of time when the map will be
 *   left alone, so the datapath can operate unhindered.
 */
#define CT_CLEAN_INTERVAL 5000 /* 5 seconds */
#define CT_CLEAN_MIN_INTERVAL 200  /* 0.2 seconds */

static void *
clean_thread_main(void *f_)
{
    struct conntrack *ct = f_;

    while (!latch_is_set(&ct->clean_thread_exit)) {
        long long next_wake;
        long long now = time_msec();
        next_wake = conntrack_clean(ct, now);

        if (next_wake < now) {
            poll_timer_wait_until(now + CT_CLEAN_MIN_INTERVAL);
        } else {
            poll_timer_wait_until(MAX(next_wake, now + CT_CLEAN_INTERVAL));
        }
        latch_wait(&ct->clean_thread_exit);
        poll_block();
    }

    return NULL;
}

/* Cleans up old connection entries from 'ct'.  Returns the time when the
 * next expiration might happen.  The return value might be smaller than
 * 'now', meaning that an internal limit has been reached, and some expired
 * connections have not been deleted. */
static long long
conntrack_clean(struct conntrack *ct, long long now)
{
    unsigned int n_conn_limit;
    atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);
    size_t clean_max = n_conn_limit > 10 ? n_conn_limit / 10 : 1;
    long long min_exp = ct_sweep(ct, now, clean_max);
    long long next_wakeup = MIN(min_exp, now + CT_DPIF_NETDEV_TP_MIN);

    return next_wakeup;
}

/* Delete the expired connections from 'ctb', up to 'limit'. Returns the
 * earliest expiration time among the remaining connections in 'ctb'.  Returns
 * LLONG_MAX if 'ctb' is empty.  The return value might be smaller than 'now',
 * if 'limit' is reached */
static long long
ct_sweep(struct conntrack *ct, long long now, size_t limit)
{
    struct conn *conn, *next;
    long long min_expiration = LLONG_MAX;
    size_t count = 0;

    ovs_mutex_lock(&ct->ct_lock);

    for (unsigned i = 0; i < N_CT_TM; i++) {
        LIST_FOR_EACH_SAFE (conn, next, exp_node, &ct->exp_lists[i]) {
            ovs_mutex_lock(&conn->lock);
            if (now < conn->expiration || count >= limit) {
                min_expiration = MIN(min_expiration, conn->expiration);
                ovs_mutex_unlock(&conn->lock);
                if (count >= limit) {
                    /* Do not check other lists. */
                    COVERAGE_INC(conntrack_long_cleanup);
                    goto out;
                }
                break;
            } else {
                ovs_mutex_unlock(&conn->lock);
                conn_clean(ct, conn);
            }
            count++;
        }
    }

out:
    VLOG_DBG("conntrack cleanup %"PRIuSIZE" entries in %lld msec", count,
             time_msec() - now);
    ovs_mutex_unlock(&ct->ct_lock);
    return min_expiration;
}

/* Must be called with 'conn' of 'conn_type' CT_CONN_TYPE_DEFAULT.  Also
 * removes the associated nat 'conn' from the lookup datastructures. */
static void
conn_clean(struct conntrack *ct, struct conn *conn)
    OVS_REQUIRES(ct->ct_lock)
{
    ovs_assert(conn->conn_type == CT_CONN_TYPE_DEFAULT);

    conn_clean_cmn(ct, conn);
    if (conn->nat_conn) {
        uint32_t hash = conn_key_hash(&conn->nat_conn->key, ct->hash_basis);
        cmap_remove(&ct->conns, &conn->nat_conn->cm_node, hash);
    }
    ovs_list_remove(&conn->exp_node);
    conn->cleaned = true;
    ovsrcu_postpone(delete_conn, conn);
    atomic_count_dec(&ct->n_conn);
}

struct ct_l4_proto ct_proto_tcp = {
    .new_conn = tcp_new_conn,
    .valid_new = tcp_valid_new,
    .conn_update = tcp_conn_update,
    .conn_get_protoinfo = tcp_conn_get_protoinfo,
};

static struct conn *
tcp_new_conn(struct conntrack *ct, struct dp_packet *pkt, long long now,
             uint32_t tp_id)
{
    struct conn_tcp* newconn = NULL;
    struct tcp_header *tcp = dp_packet_l4(pkt);
    struct tcp_peer *src, *dst;
    uint16_t tcp_flags = TCP_FLAGS(tcp->tcp_ctl);

    newconn = xzalloc(sizeof *newconn);

    src = &newconn->peer[0];
    dst = &newconn->peer[1];

    src->seqlo = ntohl(get_16aligned_be32(&tcp->tcp_seq));
    src->seqhi = src->seqlo + tcp_payload_length(pkt) + 1;

    if (tcp_flags & TCP_SYN) {
        src->seqhi++;
        src->wscale = tcp_get_wscale(tcp);
    } else {
        src->wscale = CT_WSCALE_UNKNOWN;
        dst->wscale = CT_WSCALE_UNKNOWN;
    }
    src->max_win = MAX(ntohs(tcp->tcp_winsz), 1);
    if (src->wscale & CT_WSCALE_MASK) {
        /* Remove scale factor from initial window */
        uint8_t sws = src->wscale & CT_WSCALE_MASK;
        src->max_win = DIV_ROUND_UP((uint32_t) src->max_win, 1 << sws);
    }
    if (tcp_flags & TCP_FIN) {
        src->seqhi++;
    }
    dst->seqhi = 1;
    dst->max_win = 1;
    src->state = CT_DPIF_TCPS_SYN_SENT;
    dst->state = CT_DPIF_TCPS_CLOSED;

    newconn->up.tp_id = tp_id;
    conn_init_expiration(ct, &newconn->up, CT_TM_TCP_FIRST_PACKET, now);

    return &newconn->up;
}

/* ct_lock must be held. */
void
conn_init_expiration(struct conntrack *ct, struct conn *conn,
                     enum ct_timeout tm, long long now)
    OVS_REQUIRES(ct->ct_lock)
{
    struct timeout_policy *tp;
    uint32_t val;

    tp = timeout_policy_lookup(ct, conn->tp_id);
    if (tp) {
        val = tp->policy.attrs[tm_to_ct_dpif_tp(tm)];
    } else {
        val = ct_dpif_netdev_tp_def[tm_to_ct_dpif_tp(tm)];
    }

    VLOG_DBG_RL(&rl, "Init timeout %s zone=%u with policy id=%d val=%u sec.",
                ct_timeout_str[tm], conn->key.zone, conn->tp_id, val);

    conn_init_expiration__(ct, conn, tm, now, val);
}

static void
conn_init_expiration__(struct conntrack *ct, struct conn *conn,
                       enum ct_timeout tm, long long now,
                       uint32_t tp_value)
{
    conn->expiration = now + tp_value * 1000;
    ovs_list_push_back(&ct->exp_lists[tm], &conn->exp_node);
}

static struct conn *
new_conn(struct conntrack *ct, struct dp_packet *pkt, struct conn_key *key,
         long long now, uint32_t tp_id)
{
    return l4_protos[key->nw_proto]->new_conn(ct, pkt, now, tp_id);
}

static struct conn *
conn_not_found(struct conntrack *ct, struct dp_packet *pkt,
               struct conn_lookup_ctx *ctx, bool commit, long long now,
               const struct nat_action_info_t *nat_action_info,
               const char *helper, const struct alg_exp_node *alg_exp,
               enum ct_alg_ctl_type ct_alg_ctl, uint32_t tp_id)
    OVS_REQUIRES(ct->ct_lock)
{
    struct conn *nc = NULL;
    struct conn *nat_conn = NULL;

    if (!valid_new(pkt, &ctx->key)) {
        pkt->md.ct_state = CS_INVALID;
        return nc;
    }

    pkt->md.ct_state = CS_NEW;

    if (alg_exp) {
        pkt->md.ct_state |= CS_RELATED;
    }

    if (commit) {
        struct zone_limit *zl = zone_limit_lookup_or_default(ct,
                                                             ctx->key.zone);
        if (zl && zl->czl.count >= zl->czl.limit) {
            return nc;
        }

        unsigned int n_conn_limit;
        atomic_read_relaxed(&ct->n_conn_limit, &n_conn_limit);
        if (atomic_count_get(&ct->n_conn) >= n_conn_limit) {
            COVERAGE_INC(conntrack_full);
            return nc;
        }

        nc = new_conn(ct, pkt, &ctx->key, now, tp_id);
        memcpy(&nc->key, &ctx->key, sizeof nc->key);
        memcpy(&nc->rev_key, &nc->key, sizeof nc->rev_key);
        conn_key_reverse(&nc->rev_key);

        if (ct_verify_helper(helper, ct_alg_ctl)) {
            nc->alg = nullable_xstrdup(helper);
        }

        if (alg_exp) {
            nc->alg_related = true;
            nc->mark = alg_exp->master_mark;
            nc->label = alg_exp->master_label;
            nc->master_key = alg_exp->master_key;
        }

        if (nat_action_info) {
            nc->nat_info = xmemdup(nat_action_info, sizeof *nc->nat_info);
            nat_conn = xzalloc(sizeof *nat_conn);

            if (alg_exp) {
                if (alg_exp->nat_rpl_dst) {
                    nc->rev_key.dst.addr = alg_exp->alg_nat_repl_addr;
                    nc->nat_info->nat_action = NAT_ACTION_SRC;
                } else {
                    nc->rev_key.src.addr = alg_exp->alg_nat_repl_addr;
                    nc->nat_info->nat_action = NAT_ACTION_DST;
                }
            } else {
                memcpy(nat_conn, nc, sizeof *nat_conn);
                bool nat_res = nat_select_range_tuple(ct, nc, nat_conn);

                if (!nat_res) {
                    goto nat_res_exhaustion;
                }

                /* Update nc with nat adjustments made to nat_conn by
                 * nat_select_range_tuple(). */
                memcpy(nc, nat_conn, sizeof *nc);
            }

            nat_packet(pkt, nc, ctx->icmp_related);
            memcpy(&nat_conn->key, &nc->rev_key, sizeof nat_conn->key);
            memcpy(&nat_conn->rev_key, &nc->key, sizeof nat_conn->rev_key);
            nat_conn->conn_type = CT_CONN_TYPE_UN_NAT;
            nat_conn->nat_info = NULL;
            nat_conn->alg = NULL;
            nat_conn->nat_conn = NULL;
            uint32_t nat_hash = conn_key_hash(&nat_conn->key, ct->hash_basis);
            cmap_insert(&ct->conns, &nat_conn->cm_node, nat_hash);
        }

        nc->nat_conn = nat_conn;
        ovs_mutex_init_adaptive(&nc->lock);
        nc->conn_type = CT_CONN_TYPE_DEFAULT;
        cmap_insert(&ct->conns, &nc->cm_node, ctx->hash);
        atomic_count_inc(&ct->n_conn);
        ctx->conn = nc; /* For completeness. */
        if (zl) {
            nc->admit_zone = zl->czl.zone;
            nc->zone_limit_seq = zl->czl.zone_limit_seq;
            zl->czl.count++;
        } else {
            nc->admit_zone = INVALID_ZONE;
        }
    }

    return nc;

    /* This would be a user error or a DOS attack.  A user error is prevented
     * by allocating enough combinations of NAT addresses when combined with
     * ephemeral ports.  A DOS attack should be protected against with
     * firewall rules or a separate firewall.  Also using zone partitioning
     * can limit DoS impact. */
nat_res_exhaustion:
    free(nat_conn);
    ovs_list_remove(&nc->exp_node);
    delete_conn_cmn(nc);
    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);
    VLOG_WARN_RL(&rl, "Unable to NAT due to tuple space exhaustion - "
                 "if DoS attack, use firewalling and/or zone partitioning.");
    return NULL;
}

static void
process_one(struct conntrack *ct, struct dp_packet *pkt,
            struct conn_lookup_ctx *ctx, uint16_t zone,
            bool force, bool commit, long long now, const uint32_t *setmark,
            const struct ovs_key_ct_labels *setlabel,
            const struct nat_action_info_t *nat_action_info,
            ovs_be16 tp_src, ovs_be16 tp_dst, const char *helper,
            uint32_t tp_id)
{
    /* Reset ct_state whenever entering a new zone. */
    if (pkt->md.ct_state && pkt->md.ct_zone != zone) {
        pkt->md.ct_state = 0;
    }

    bool create_new_conn = false;
    conn_key_lookup(ct, &ctx->key, ctx->hash, now, &ctx->conn, &ctx->reply);
    struct conn *conn = ctx->conn;

    /* Delete found entry if in wrong direction. 'force' implies commit. */
    if (OVS_UNLIKELY(force && ctx->reply && conn)) {
        ovs_mutex_lock(&ct->ct_lock);
        if (conn_lookup(ct, &conn->key, now, NULL, NULL)) {
            conn_clean(ct, conn);
        }
        ovs_mutex_unlock(&ct->ct_lock);
        conn = NULL;
    }

    if (OVS_LIKELY(conn)) {
        if (conn->conn_type == CT_CONN_TYPE_UN_NAT) {

            ctx->reply = true;
            struct conn *rev_conn = conn;  /* Save for debugging. */
            uint32_t hash = conn_key_hash(&conn->rev_key, ct->hash_basis);
            conn_key_lookup(ct, &ctx->key, hash, now, &conn, &ctx->reply);

            if (!conn) {
                pkt->md.ct_state |= CS_INVALID;
                write_ct_md(pkt, zone, NULL, NULL, NULL);
                char *log_msg = xasprintf("Missing master conn %p", rev_conn);
                ct_print_conn_info(rev_conn, log_msg, VLL_INFO, true, true);
                free(log_msg);
                return;
            }
        }
    }

    enum ct_alg_ctl_type ct_alg_ctl = get_alg_ctl_type(pkt, tp_src, tp_dst,
                                                       helper);

    if (OVS_LIKELY(conn)) {
        if (OVS_LIKELY(!conn_update_state_alg(ct, pkt, ctx, conn,
                                              nat_action_info,
                                              ct_alg_ctl, now,
                                              &create_new_conn))) {
            create_new_conn = conn_update_state(ct, pkt, ctx, conn, now);
        }
        if (nat_action_info && !create_new_conn) {
            handle_nat(pkt, conn, zone, ctx->reply, ctx->icmp_related);
        }

    } else if (check_orig_tuple(ct, pkt, ctx, now, &conn, nat_action_info)) {
        create_new_conn = conn_update_state(ct, pkt, ctx, conn, now);
    } else {
        if (ctx->icmp_related) {
            /* An icmp related conn should always be found; no new
               connection is created based on an icmp related packet. */
            pkt->md.ct_state = CS_INVALID;
        } else {
            create_new_conn = true;
        }
    }

    const struct alg_exp_node *alg_exp = NULL;
    struct alg_exp_node alg_exp_entry;

    if (OVS_UNLIKELY(create_new_conn)) {

        ovs_rwlock_rdlock(&ct->resources_lock);
        alg_exp = expectation_lookup(&ct->alg_expectations, &ctx->key,
                                     ct->hash_basis,
                                     alg_src_ip_wc(ct_alg_ctl));
        if (alg_exp) {
            memcpy(&alg_exp_entry, alg_exp, sizeof alg_exp_entry);
            alg_exp = &alg_exp_entry;
        }
        ovs_rwlock_unlock(&ct->resources_lock);

        ovs_mutex_lock(&ct->ct_lock);
        if (!conn_lookup(ct, &ctx->key, now, NULL, NULL)) {
            conn = conn_not_found(ct, pkt, ctx, commit, now, nat_action_info,
                                  helper, alg_exp, ct_alg_ctl, tp_id);
        }
        ovs_mutex_unlock(&ct->ct_lock);
    }

    write_ct_md(pkt, zone, conn, &ctx->key, alg_exp);

    if (conn && setmark) {
        set_mark(pkt, conn, setmark[0], setmark[1]);
    }

    if (conn && setlabel) {
        set_label(pkt, conn, &setlabel[0], &setlabel[1]);
    }

    handle_alg_ctl(ct, ctx, pkt, ct_alg_ctl, conn, now, !!nat_action_info);

    set_cached_conn(nat_action_info, ctx, conn, pkt);
}

/* Sends the packets in '*pkt_batch' through the connection tracker 'ct'.  All
 * the packets must have the same 'dl_type' (IPv4 or IPv6) and should have
 * the l3 and and l4 offset properly set.  Performs fragment reassembly with
 * the help of ipf_preprocess_conntrack().
 *
 * If 'commit' is true, the packets are allowed to create new entries in the
 * connection tables.  'setmark', if not NULL, should point to a two
 * elements array containing a value and a mask to set the connection mark.
 * 'setlabel' behaves similarly for the connection label.*/
int
conntrack_execute(struct conntrack *ct, struct dp_packet_batch *pkt_batch,
                  ovs_be16 dl_type, bool force, bool commit, uint16_t zone,
                  const uint32_t *setmark,
                  const struct ovs_key_ct_labels *setlabel,
                  ovs_be16 tp_src, ovs_be16 tp_dst, const char *helper,
                  const struct nat_action_info_t *nat_action_info,
                  long long now, uint32_t tp_id)
{
    ipf_preprocess_conntrack(ct->ipf, pkt_batch, now, dl_type, zone,
                             ct->hash_basis);

    struct dp_packet *packet;
    struct conn_lookup_ctx ctx;

    DP_PACKET_BATCH_FOR_EACH (i, packet, pkt_batch) {
        struct conn *conn = packet->md.conn;
        if (OVS_UNLIKELY(packet->md.ct_state == CS_INVALID)) {
            write_ct_md(packet, zone, NULL, NULL, NULL);
        } else if (conn && conn->key.zone == zone && !force
                   && !get_alg_ctl_type(packet, tp_src, tp_dst, helper)) {
            process_one_fast(zone, setmark, setlabel, nat_action_info,
                             conn, packet);
        } else if (OVS_UNLIKELY(!conn_key_extract(ct, packet, dl_type, &ctx,
                                zone))) {
            packet->md.ct_state = CS_INVALID;
            write_ct_md(packet, zone, NULL, NULL, NULL);
        } else {
            process_one(ct, packet, &ctx, zone, force, commit, now, setmark,
                        setlabel, nat_action_info, tp_src, tp_dst, helper,
                        tp_id);
        }
    }

    ipf_postprocess_conntrack(ct->ipf, pkt_batch, now, dl_type);

    return 0;
}

也就是说DPDK模式的conntrack是自己实现的

static void
dp_execute_cb(void *aux_, struct dp_packet_batch *packets_,
              const struct nlattr *a, bool should_steal)
    OVS_NO_THREAD_SAFETY_ANALYSIS
{
    struct dp_netdev_execute_aux *aux = aux_;
    uint32_t *depth = recirc_depth_get();
    struct dp_netdev_pmd_thread *pmd = aux->pmd;
    struct dp_netdev *dp = pmd->dp;
    int type = nl_attr_type(a);
    struct tx_port *p;
    uint32_t packet_count, packets_dropped;

    switch ((enum ovs_action_attr)type) {
    case OVS_ACTION_ATTR_OUTPUT:
        dp_execute_output_action(pmd, packets_, should_steal,
                                 nl_attr_get_odp_port(a));
        return;

    case OVS_ACTION_ATTR_LB_OUTPUT:
        dp_execute_lb_output_action(pmd, packets_, should_steal,
                                    nl_attr_get_u32(a));
        return;

    case OVS_ACTION_ATTR_TUNNEL_PUSH:
        if (should_steal) {
            /* We're requested to push tunnel header, but also we need to take
             * the ownership of these packets. Thus, we can avoid performing
             * the action, because the caller will not use the result anyway.
             * Just break to free the batch. */
            break;
        }
        dp_packet_batch_apply_cutlen(packets_);
        packet_count = dp_packet_batch_size(packets_);
        if (push_tnl_action(pmd, a, packets_)) {
            COVERAGE_ADD(datapath_drop_tunnel_push_error,
                         packet_count);
        }
        return;

    case OVS_ACTION_ATTR_TUNNEL_POP:
        if (*depth < MAX_RECIRC_DEPTH) {
            struct dp_packet_batch *orig_packets_ = packets_;
            odp_port_t portno = nl_attr_get_odp_port(a);

            p = pmd_tnl_port_cache_lookup(pmd, portno);
            if (p) {
                struct dp_packet_batch tnl_pkt;

                if (!should_steal) {
                    dp_packet_batch_clone(&tnl_pkt, packets_);
                    packets_ = &tnl_pkt;
                    dp_packet_batch_reset_cutlen(orig_packets_);
                }

                dp_packet_batch_apply_cutlen(packets_);

                packet_count = dp_packet_batch_size(packets_);
                netdev_pop_header(p->port->netdev, packets_);
                packets_dropped =
                   packet_count - dp_packet_batch_size(packets_);
                if (packets_dropped) {
                    COVERAGE_ADD(datapath_drop_tunnel_pop_error,
                                 packets_dropped);
                }
                if (dp_packet_batch_is_empty(packets_)) {
                    return;
                }

                struct dp_packet *packet;
                DP_PACKET_BATCH_FOR_EACH (i, packet, packets_) {
                    packet->md.in_port.odp_port = portno;
                }

                (*depth)++;
                dp_netdev_recirculate(pmd, packets_);
                (*depth)--;
                return;
            }
            COVERAGE_ADD(datapath_drop_invalid_tnl_port,
                         dp_packet_batch_size(packets_));
        } else {
            COVERAGE_ADD(datapath_drop_recirc_error,
                         dp_packet_batch_size(packets_));
        }
        break;

    case OVS_ACTION_ATTR_USERSPACE:
        if (!fat_rwlock_tryrdlock(&dp->upcall_rwlock)) {
            struct dp_packet_batch *orig_packets_ = packets_;
            const struct nlattr *userdata;
            struct dp_packet_batch usr_pkt;
            struct ofpbuf actions;
            struct flow flow;
            ovs_u128 ufid;
            bool clone = false;

            userdata = nl_attr_find_nested(a, OVS_USERSPACE_ATTR_USERDATA);
            ofpbuf_init(&actions, 0);

            if (packets_->trunc) {
                if (!should_steal) {
                    dp_packet_batch_clone(&usr_pkt, packets_);
                    packets_ = &usr_pkt;
                    clone = true;
                    dp_packet_batch_reset_cutlen(orig_packets_);
                }

                dp_packet_batch_apply_cutlen(packets_);
            }

            struct dp_packet *packet;
            DP_PACKET_BATCH_FOR_EACH (i, packet, packets_) {
                flow_extract(packet, &flow);
                odp_flow_key_hash(&flow, sizeof flow, &ufid);
                dp_execute_userspace_action(pmd, packet, should_steal, &flow,
                                            &ufid, &actions, userdata);
            }

            if (clone) {
                dp_packet_delete_batch(packets_, true);
            }

            ofpbuf_uninit(&actions);
            fat_rwlock_unlock(&dp->upcall_rwlock);

            return;
        }
        COVERAGE_ADD(datapath_drop_lock_error,
                     dp_packet_batch_size(packets_));
        break;

    case OVS_ACTION_ATTR_RECIRC:
        if (*depth < MAX_RECIRC_DEPTH) {
            struct dp_packet_batch recirc_pkts;

            if (!should_steal) {
               dp_packet_batch_clone(&recirc_pkts, packets_);
               packets_ = &recirc_pkts;
            }

            struct dp_packet *packet;
            DP_PACKET_BATCH_FOR_EACH (i, packet, packets_) {
                packet->md.recirc_id = nl_attr_get_u32(a);
            }

            (*depth)++;
            dp_netdev_recirculate(pmd, packets_);
            (*depth)--;

            return;
        }

        COVERAGE_ADD(datapath_drop_recirc_error,
                     dp_packet_batch_size(packets_));
        VLOG_WARN("Packet dropped. Max recirculation depth exceeded.");
        break;

    case OVS_ACTION_ATTR_CT: {
        const struct nlattr *b;
        bool force = false;
        bool commit = false;
        unsigned int left;
        uint16_t zone = 0;
        uint32_t tp_id = 0;
        const char *helper = NULL;
        const uint32_t *setmark = NULL;
        const struct ovs_key_ct_labels *setlabel = NULL;
        struct nat_action_info_t nat_action_info;
        struct nat_action_info_t *nat_action_info_ref = NULL;
        bool nat_config = false;

        NL_ATTR_FOR_EACH_UNSAFE (b, left, nl_attr_get(a),
                                 nl_attr_get_size(a)) {
            enum ovs_ct_attr sub_type = nl_attr_type(b);

            switch(sub_type) {
            case OVS_CT_ATTR_FORCE_COMMIT:
                force = true;
                /* fall through. */
            case OVS_CT_ATTR_COMMIT:
                commit = true;
                break;
            case OVS_CT_ATTR_ZONE:
                zone = nl_attr_get_u16(b);
                break;
            case OVS_CT_ATTR_HELPER:
                helper = nl_attr_get_string(b);
                break;
            case OVS_CT_ATTR_MARK:
                setmark = nl_attr_get(b);
                break;
            case OVS_CT_ATTR_LABELS:
                setlabel = nl_attr_get(b);
                break;
            case OVS_CT_ATTR_EVENTMASK:
                /* Silently ignored, as userspace datapath does not generate
                 * netlink events. */
                break;
            case OVS_CT_ATTR_TIMEOUT:
                if (!str_to_uint(nl_attr_get_string(b), 10, &tp_id)) {
                    VLOG_WARN("Invalid Timeout Policy ID: %s.",
                              nl_attr_get_string(b));
                    tp_id = DEFAULT_TP_ID;
                }
                break;
            case OVS_CT_ATTR_NAT: {
                const struct nlattr *b_nest;
                unsigned int left_nest;
                bool ip_min_specified = false;
                bool proto_num_min_specified = false;
                bool ip_max_specified = false;
                bool proto_num_max_specified = false;
                memset(&nat_action_info, 0, sizeof nat_action_info);
                nat_action_info_ref = &nat_action_info;

                NL_NESTED_FOR_EACH_UNSAFE (b_nest, left_nest, b) {
                    enum ovs_nat_attr sub_type_nest = nl_attr_type(b_nest);

                    switch (sub_type_nest) {
                    case OVS_NAT_ATTR_SRC:
                    case OVS_NAT_ATTR_DST:
                        nat_config = true;
                        nat_action_info.nat_action |=
                            ((sub_type_nest == OVS_NAT_ATTR_SRC)
                                ? NAT_ACTION_SRC : NAT_ACTION_DST);
                        break;
                    case OVS_NAT_ATTR_IP_MIN:
                        memcpy(&nat_action_info.min_addr,
                               nl_attr_get(b_nest),
                               nl_attr_get_size(b_nest));
                        ip_min_specified = true;
                        break;
                    case OVS_NAT_ATTR_IP_MAX:
                        memcpy(&nat_action_info.max_addr,
                               nl_attr_get(b_nest),
                               nl_attr_get_size(b_nest));
                        ip_max_specified = true;
                        break;
                    case OVS_NAT_ATTR_PROTO_MIN:
                        nat_action_info.min_port =
                            nl_attr_get_u16(b_nest);
                        proto_num_min_specified = true;
                        break;
                    case OVS_NAT_ATTR_PROTO_MAX:
                        nat_action_info.max_port =
                            nl_attr_get_u16(b_nest);
                        proto_num_max_specified = true;
                        break;
                    case OVS_NAT_ATTR_PERSISTENT:
                    case OVS_NAT_ATTR_PROTO_HASH:
                    case OVS_NAT_ATTR_PROTO_RANDOM:
                        break;
                    case OVS_NAT_ATTR_UNSPEC:
                    case __OVS_NAT_ATTR_MAX:
                        OVS_NOT_REACHED();
                    }
                }

                if (ip_min_specified && !ip_max_specified) {
                    nat_action_info.max_addr = nat_action_info.min_addr;
                }
                if (proto_num_min_specified && !proto_num_max_specified) {
                    nat_action_info.max_port = nat_action_info.min_port;
                }
                if (proto_num_min_specified || proto_num_max_specified) {
                    if (nat_action_info.nat_action & NAT_ACTION_SRC) {
                        nat_action_info.nat_action |= NAT_ACTION_SRC_PORT;
                    } else if (nat_action_info.nat_action & NAT_ACTION_DST) {
                        nat_action_info.nat_action |= NAT_ACTION_DST_PORT;
                    }
                }
                break;
            }
            case OVS_CT_ATTR_UNSPEC:
            case __OVS_CT_ATTR_MAX:
                OVS_NOT_REACHED();
            }
        }

        /* We won't be able to function properly in this case, hence
         * complain loudly. */
        if (nat_config && !commit) {
            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 5);
            VLOG_WARN_RL(&rl, "NAT specified without commit.");
        }

        conntrack_execute(dp->conntrack, packets_, aux->flow->dl_type, force,
                          commit, zone, setmark, setlabel, aux->flow->tp_src,
                          aux->flow->tp_dst, helper, nat_action_info_ref,
                          pmd->ctx.now / 1000, tp_id);
        break;
    }

    case OVS_ACTION_ATTR_METER:
        dp_netdev_run_meter(pmd->dp, packets_, nl_attr_get_u32(a),
                            pmd->ctx.now);
        break;

    case OVS_ACTION_ATTR_PUSH_VLAN:
    case OVS_ACTION_ATTR_POP_VLAN:
    case OVS_ACTION_ATTR_PUSH_MPLS:
    case OVS_ACTION_ATTR_POP_MPLS:
    case OVS_ACTION_ATTR_SET:
    case OVS_ACTION_ATTR_SET_MASKED:
    case OVS_ACTION_ATTR_SAMPLE:
    case OVS_ACTION_ATTR_HASH:
    case OVS_ACTION_ATTR_UNSPEC:
    case OVS_ACTION_ATTR_TRUNC:
    case OVS_ACTION_ATTR_PUSH_ETH:
    case OVS_ACTION_ATTR_POP_ETH:
    case OVS_ACTION_ATTR_CLONE:
    case OVS_ACTION_ATTR_PUSH_NSH:
    case OVS_ACTION_ATTR_POP_NSH:
    case OVS_ACTION_ATTR_CT_CLEAR:
    case OVS_ACTION_ATTR_CHECK_PKT_LEN:
    case OVS_ACTION_ATTR_DROP:
    //XXXXXXXX 7.DPDK mode action execution
    case OVS_ACTION_ATTR_CONFIG_GW:
    case OVS_ACTION_ATTR_HANDLE_GW:
    case __OVS_ACTION_ATTR_MAX:
        OVS_NOT_REACHED();
    }

    dp_packet_delete_batch(packets_, should_steal);
}


///////////我们沿着ovs调用过程来解析commit到conntrack的过程


内核datapath模式

(1) 快路径	

netdev_port_receive
->ovs_vport_receive
->ovs_dp_process_received_packet
->   ovs_flow_extract
   + ovs_flow_tbl_lookup
   + ovs_dp_upcall -> queue_userspace_packet
 -> genlmsg_unicast (发送消息给用户空间)
   + ovs_execute_actions -> do_execute_actions (快路径执行action)

(2) 用户态upcall接收线程

ovs_thread_create->udpif_upcall_handler->recv_upcalls(内核态datapath模式用户态处理upcall的核心函数)
handler线程只对传统ovs架构下,对内核upcall的消息进行处理。即慢速路径的处理就是handler线程的工作内容。

(3) 处理upcall的核心函数	

recv_upcalls(内核态模式处理upcall的核心函数)
->  upcall_receive (无论是内核模式，还是DPDK模式，都先调用upcall_receive，两者的type都是一样的，都是DPIF_UC_MISS(就是MISS_UPCALL)，不同的是，内核PMD是PMD_ID_NULL，而DPDK的PMD有pmd_id)
  + process_upcall (无论是内核模式，还是DPDK模式，都再调用process_upcall查找openflow流表，并对于actions进行转换)
  + handle_upcalls (这里只有内核模式有，安装流表到内核，并在内核执行action)

(4) 慢路径做action的转换	

process_upcall->upcall_xlate->xlate_actions
->rule_dpif_lookup_from_table (到table的分类器中查找流表)
  + do_xlate_actions

xlate_actions函数：openflow流表匹配完成后，调用do_xlate_actions函数把openflow action转化为数据面的action

(5) 慢路径action的执行, 并将action加入数据面

handle_upcalls 将flow rule添加到内核中的fast path(如果should_install_flow为true，put_op_init里面设置op->dop.type = DPIF_OP_FLOW_PUT)，且在内核执行action(设置op->dop.type = DPIF_OP_EXECUTE) 
-> dpif_operate -> dpif_netlink_operate -> dpif_netlink_operate_chunks -> dpif_netlink_operate__ (case DPIF_OP_FLOW_PUT: dpif_netlink_init_flow_put + dpif_netlink_flow_to_ofpbuf ; case DPIF_OP_EXECUTE: dpif_netlink_encode_execute)
+ nl_transact_multiple(通过netlink发送给内核)

接下来我们到内核里面datapath\datapath.c

内核将action放到内核流表中
OVS_FLOW_CMD_NEW->ovs_flow_cmd_new
->   ovs_flow_alloc //分配一个内核流表
   + ovs_nla_get_match(OVS_FLOW_ATTR_KEY) /* Extract key. 从netlink消息里面获取流表的key */
   + ovs_nla_copy_actions(OVS_FLOW_ATTR_ACTIONS) /* Validate actions. 从netlink消息里面获取流表的actions */
   + ovs_flow_tbl_insert(&dp->table, new_flow, &mask)

内核执行upcall下发过来的action
OVS_PACKET_CMD_EXECUTE->ovs_packet_cmd_execute->ovs_execute_actions->do_execute_actions


/*XXXXXXXX 1.define openflow action: add openflow action type*/
    /* NX1.0+(35): struct nx_action_conntrack, ... VLMFF */
    NXAST_RAW_CT,
    /* NX1.0+(43): void. */
    NXAST_RAW_CT_CLEAR,
/*XXXXXXXX 2.define openvswitch action*/
//XXXXXXXX 2.define openvswitch action: define action struct
    OFPACT(CT,              ofpact_conntrack,   ofpact, "ct")           \
    OFPACT(CT_CLEAR,        ofpact_null,        ofpact, "ct_clear")     \

/* OFPACT_CT.
 *
 * Used for NXAST_CT. */
struct ofpact_conntrack {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint16_t flags;
        uint16_t zone_imm;
        struct mf_subfield zone_src;
        uint16_t alg;
        uint8_t recirc_table;
    );
    struct ofpact actions[0];
};
//XXXXXXXX 3.translate between openflow action and openvswitch action: decode, encode, parse, format, check
//XXXXXXXX 4.define datapath action
//XXXXXXXX 4.XXX define datapath action: define data path action struct
enum ovs_action_attr {
	OVS_ACTION_ATTR_CT,           /* Nested OVS_CT_ATTR_* . */
	OVS_ACTION_ATTR_CT_CLEAR,     /* No argument. */
	__OVS_ACTION_ATTR_MAX,	      /* Nothing past this will be accepted
				       * from userspace. */
};
//XXXXXXXX 5.handle upcall, translate openvswitch action to datapath action
static void
do_xlate_actions(const struct ofpact *ofpacts, size_t ofpacts_len,
                 struct xlate_ctx *ctx, bool is_last_action,
                 bool group_bucket_action)
        case OFPACT_CT:
            compose_conntrack_action(ctx, ofpact_get_CT(a), last);
            break;

        case OFPACT_CT_CLEAR:
            compose_ct_clear_action(ctx);
            break;

static int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,
				  const struct sw_flow_key *key,
				  struct sw_flow_actions **sfa,
				  __be16 eth_type, __be16 vlan_tci,
				  u32 mpls_label_count, bool log)

			[OVS_ACTION_ATTR_CT] = (u32)-1,
			[OVS_ACTION_ATTR_CT_CLEAR] = 0,

		case OVS_ACTION_ATTR_CT:
			err = ovs_ct_copy_action(net, a, key, sfa, log);
			if (err)
				return err;
			skip_copy = true;
			break;

		case OVS_ACTION_ATTR_CT_CLEAR:
			break;

//XXXXXXXX 6.kernel datapath action exeution
static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,
			      struct sw_flow_key *key,
			      const struct nlattr *attr, int len)

		case OVS_ACTION_ATTR_CT:
			if (!is_flow_key_valid(key)) {
				err = ovs_flow_key_update(skb, key);
				if (err)
					return err;
			}

			err = ovs_ct_execute(ovs_dp_get_net(dp), skb, key,
					     nla_data(a));

			/* Hide stolen IP fragments from user space. */
			if (err)
				return err == -EINPROGRESS ? 0 : err;
			break;

		case OVS_ACTION_ATTR_CT_CLEAR:
			err = ovs_ct_clear(skb, key);
			break;
//XXXXXXXX 7.DPDK mode action execution


///////////////////////////////////////////////////////////////////

接下来一是了解linux内核netfilter的实现，二是看ovs如何调用的netfilter，三是看ovs是否可以通过调研netfilter来实现ACL

我们先来看linux内核netfilter的实现

Netfilter 在四个 Hook 点对包进行跟踪：

PRE_ROUTING 和 LOCAL_OUT ：调用 nf_conntrack_in() 开始连接跟踪， 正常情况下会创建一条新连接记录，然后将 conntrack entry 放到unconfirmed list。

为什么是这两个 hook 点呢？因为它们都是新连接的第一个包最先达到的地方，

PRE_ROUTING 是外部主动和本机建连时包最先到达的地方
LOCAL_OUT 是本机主动和外部建连时包最先到达的地方

POST_ROUTING 和 LOCAL_IN：调用 nf_conntrack_confirm() 将 nf_conntrack_in() 创建的连接移到 confirmed list。

同样要问，为什么在这两个 hook 点呢？因为如果新连接的第一个包没有被丢弃，那这 是它们离开 netfilter 之前的最后 hook 点：

外部主动和本机建连的包，如果在中间处理中没有被丢弃，LOCAL_IN 是其被送到应用（例如 nginx 服务）之前的最后 hook 点
本机主动和外部建连的包，如果在中间处理中没有被丢弃，POST_ROUTING 是其离开主机时的最后 hook 点

下面的代码可以看到这些 handler 是如何注册到 Netfilter hook 点的：

// net/netfilter/nf_conntrack_proto.c

/* Connection tracking may drop packets, but never alters them, so make it the first hook.  */
static const struct nf_hook_ops ipv4_conntrack_ops[] = {
    {
        .hook        = ipv4_conntrack_in,       // 调用 nf_conntrack_in() 进入连接跟踪
        .pf          = NFPROTO_IPV4,
        .hooknum     = NF_INET_PRE_ROUTING,     // PRE_ROUTING hook 点
        .priority    = NF_IP_PRI_CONNTRACK,
    },
    {
        .hook        = ipv4_conntrack_local,    // 调用 nf_conntrack_in() 进入连接跟踪
        .pf          = NFPROTO_IPV4,
        .hooknum     = NF_INET_LOCAL_OUT,       // LOCAL_OUT hook 点
        .priority    = NF_IP_PRI_CONNTRACK,
    },
    {
        .hook        = ipv4_confirm,            // 调用 nf_conntrack_confirm()
        .pf          = NFPROTO_IPV4,
        .hooknum     = NF_INET_POST_ROUTING,    // POST_ROUTING hook 点
        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,
    },
    {
        .hook        = ipv4_confirm,            // 调用 nf_conntrack_confirm()
        .pf          = NFPROTO_IPV4,
        .hooknum     = NF_INET_LOCAL_IN,        // LOCAL_IN hook 点
        .priority    = NF_IP_PRI_CONNTRACK_CONFIRM,
    },
};

nf_conntrack_in() 是连接跟踪模块的核心。

// net/netfilter/nf_conntrack_core.c

unsigned int
nf_conntrack_in(struct net *net, u_int8_t pf, unsigned int hooknum, struct sk_buff *skb)
{
  struct nf_conn *tmpl = nf_ct_get(skb, &ctinfo); // 获取 skb 对应的 conntrack_info 和连接记录
  if (tmpl || ctinfo == IP_CT_UNTRACKED) {        // 如果记录存在，或者是不需要跟踪的类型
      if ((tmpl && !nf_ct_is_template(tmpl)) || ctinfo == IP_CT_UNTRACKED) {
          NF_CT_STAT_INC_ATOMIC(net, ignore);     // 无需跟踪的类型，增加 ignore 计数
          return NF_ACCEPT;                       // 返回 NF_ACCEPT，继续后面的处理
      }
      skb->_nfct = 0;                             // 不属于 ignore 类型，计数器置零，准备后续处理
  }

  struct nf_conntrack_l4proto *l4proto = __nf_ct_l4proto_find(...);    // 提取协议相关的 L4 头信息

  if (l4proto->error != NULL) {                   // skb 的完整性和合法性验证
      if (l4proto->error(net, tmpl, skb, dataoff, pf, hooknum) <= 0) {
          NF_CT_STAT_INC_ATOMIC(net, error);
          NF_CT_STAT_INC_ATOMIC(net, invalid);
          goto out;
      }
  }

repeat:
  // 开始连接跟踪：提取 tuple；创建新连接记录，或者更新已有连接的状态
  resolve_normal_ct(net, tmpl, skb, ... l4proto);

  l4proto->packet(ct, skb, dataoff, ctinfo); // 进行一些协议相关的处理，例如 UDP 会更新 timeout

  if (ctinfo == IP_CT_ESTABLISHED_REPLY && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
      nf_conntrack_event_cache(IPCT_REPLY, ct);
out:
  if (tmpl)
      nf_ct_put(tmpl); // 解除对连接记录 tmpl 的引用
}

大致流程：

1.尝试获取这个 skb 对应的连接跟踪记录
2.判断是否需要对这个包做连接跟踪，如果不需要，更新 ignore 计数（conntrack -S 能看到这个计数）， 返回 NF_ACCEPT；如果需要，就初始化这个 skb 的引用计数。
3.从包的 L4 header 中提取信息，初始化协议相关的 struct nf_conntrack_l4proto {} 变量，其中包含了该协议的连接跟踪相关的回调方法。
4.调用该协议的 error() 方法检查包的完整性、校验和等信息。
5.调用 resolve_normal_ct() 开始连接跟踪，它会创建新 tuple，新 conntrack entry，或者更新已有连接的状态。
6.调用该协议的 packet() 方法进行一些协议相关的处理，例如对于 UDP，如果 status bit 里面设置了 IPS_SEEN_REPLY 位，就会更新 timeout。timeout 大小和协 议相关，越小越越可以防止 DoS 攻击（DoS 的基本原理就是将机器的可用连接耗尽）

/* On success, returns 0, sets skb->_nfct | ctinfo */
static int
resolve_normal_ct(struct nf_conn *tmpl,
		  struct sk_buff *skb,
		  unsigned int dataoff,
		  u_int8_t protonum,
		  const struct nf_hook_state *state)
{
	const struct nf_conntrack_zone *zone;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_hash *h;
	enum ip_conntrack_info ctinfo;
	struct nf_conntrack_zone tmp;
	struct nf_conn *ct;
	u32 hash;

	if (!nf_ct_get_tuple(skb, skb_network_offset(skb),
			     dataoff, state->pf, protonum, state->net,
			     &tuple)) {
		pr_debug("Can't get tuple\n");
		return 0;
	}

	/* look for tuple match */
	zone = nf_ct_zone_tmpl(tmpl, skb, &tmp);
	hash = hash_conntrack_raw(&tuple, state->net);
	h = __nf_conntrack_find_get(state->net, zone, &tuple, hash);
	if (!h) {
		h = init_conntrack(state->net, tmpl, &tuple,
				   skb, dataoff, hash);
		if (!h)
			return 0;
		if (IS_ERR(h))
			return PTR_ERR(h);
	}
	ct = nf_ct_tuplehash_to_ctrack(h);

	/* It exists; we have (non-exclusive) reference. */
	if (NF_CT_DIRECTION(h) == IP_CT_DIR_REPLY) {
		ctinfo = IP_CT_ESTABLISHED_REPLY;
	} else {
		/* Once we've had two way comms, always ESTABLISHED. */
		if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
			pr_debug("normal packet for %p\n", ct);
			ctinfo = IP_CT_ESTABLISHED;
		} else if (test_bit(IPS_EXPECTED_BIT, &ct->status)) {
			pr_debug("related packet for %p\n", ct);
			ctinfo = IP_CT_RELATED;
		} else {
			pr_debug("new packet for %p\n", ct);
			ctinfo = IP_CT_NEW;
		}
	}
	nf_ct_set(skb, ct, ctinfo);
	return 0;
}

init_conntrack()：创建新连接记录

如果连接不存在（flow 的第一个包），resolve_normal_ct() 会调用 init_conntrack ，后者进而会调用 new() 方法创建一个新的 conntrack entry。

// include/net/netfilter/nf_conntrack_core.c
// Allocate a new conntrack
static noinline struct nf_conntrack_tuple_hash *
init_conntrack(struct net *net, struct nf_conn *tmpl,
           const struct nf_conntrack_tuple *tuple,
           const struct nf_conntrack_l4proto *l4proto,
           struct sk_buff *skb, unsigned int dataoff, u32 hash)
{
    struct nf_conn *ct;

    // 从 conntrack table 中分配一个 entry，如果哈希表满了，会在内核日志中打印
    // "nf_conntrack: table full, dropping packet" 信息，通过 `dmesg -T` 能看到
    ct = __nf_conntrack_alloc(net, zone, tuple, &repl_tuple, GFP_ATOMIC, hash);

    l4proto->new(ct, skb, dataoff); // 协议相关的方法

    local_bh_disable();             // 关闭软中断
    if (net->ct.expect_count) {
        exp = nf_ct_find_expectation(net, zone, tuple);
        if (exp) {
            /* Welcome, Mr. Bond.  We've been expecting you... */
            __set_bit(IPS_EXPECTED_BIT, &ct->status);

            /* exp->master safe, refcnt bumped in nf_ct_find_expectation */
            ct->master = exp->master;
            ct->mark = exp->master->mark;
            ct->secmark = exp->master->secmark;
            NF_CT_STAT_INC(net, expect_new);
        }
    }

    /* Now it is inserted into the unconfirmed list, bump refcount */
    // 至此这个新的 conntrack entry 已经被插入 unconfirmed list
    nf_conntrack_get(&ct->ct_general);
    nf_ct_add_to_unconfirmed_list(ct);

    local_bh_enable();              // 重新打开软中断

    if (exp) {
        if (exp->expectfn)
            exp->expectfn(ct, exp);
        nf_ct_expect_put(exp);
    }

    return &ct->tuplehash[IP_CT_DIR_ORIGINAL];
}

每种协议需要实现自己的 l4proto->new() 方法，代码见：net/netfilter/nf_conntrack_proto_*.c。 例如 TCP 协议对应的 new() 方法是：

// net/netfilter/nf_conntrack_proto_tcp.c

/* Called when a new connection for this protocol found. */
static bool tcp_new(struct nf_conn *ct, const struct sk_buff *skb, unsigned int dataoff)
{
    if (new_state == TCP_CONNTRACK_SYN_SENT) {
        memset(&ct->proto.tcp, 0, sizeof(ct->proto.tcp));
        /* SYN packet */
        ct->proto.tcp.seen[0].td_end = segment_seq_plus_len(ntohl(th->seq), skb->len, dataoff, th);
        ct->proto.tcp.seen[0].td_maxwin = ntohs(th->window);
        ...
}

如果当前包会影响后面包的状态判断，init_conntrack() 会设置 struct nf_conn 的 master 字段。面向连接的协议会用到这个特性，例如 TCP。

nf_conntrack_confirm()：确认包没有被丢弃

nf_conntrack_in() 创建的新 conntrack entry 会插入到一个 未确认连接（unconfirmed connection）列表。

如果这个包之后没有被丢弃，那它在经过POST_ROUTING时会被nf_conntrack_confirm()方法处理，原理我们在分析过了 3.6 节的开头分析过了。nf_conntrack_confirm()完成之后，状态就变为了IPS_CONFIRMED，并且连接记录从未确认列表移到正常的列表。

之所以把创建一个新 entry 的过程分为创建（new）和确认（confirm）两个阶段 ，是因为包在经过 nf_conntrack_in() 之后，到达 nf_conntrack_confirm() 之前 ，可能会被内核丢弃。这样会导致系统残留大量的半连接状态记录，在性能和安全性上都 是很大问题。分为两步之后，可以加快半连接状态 conntrack entry 的 GC。

// include/net/netfilter/nf_conntrack_core.h

/* Confirm a connection: returns NF_DROP if packet must be dropped. */
static inline int nf_conntrack_confirm(struct sk_buff *skb)
{
    struct nf_conn *ct = (struct nf_conn *)skb_nfct(skb);
    int ret = NF_ACCEPT;

    if (ct) {
        if (!nf_ct_is_confirmed(ct))
            ret = __nf_conntrack_confirm(skb);
        if (likely(ret == NF_ACCEPT))
            nf_ct_deliver_cached_events(ct);
    }
    return ret;
}

confirm 逻辑，省略了各种错误处理逻辑：

// net/netfilter/nf_conntrack_core.c

/* Confirm a connection given skb; places it in hash table */
int
__nf_conntrack_confirm(struct sk_buff *skb)
{
    struct nf_conn *ct;
    ct = nf_ct_get(skb, &ctinfo);

    local_bh_disable();               // 关闭软中断

    hash = *(unsigned long *)&ct->tuplehash[IP_CT_DIR_REPLY].hnnode.pprev;
    reply_hash = hash_conntrack(net, &ct->tuplehash[IP_CT_DIR_REPLY].tuple);

    ct->timeout += nfct_time_stamp;   // 更新连接超时时间，超时后会被 GC
    atomic_inc(&ct->ct_general.use);  // 设置连接引用计数？
    ct->status |= IPS_CONFIRMED;      // 设置连接状态为 confirmed

    __nf_conntrack_hash_insert(ct, hash, reply_hash);  // 插入到连接跟踪哈希表

    local_bh_enable();                // 重新打开软中断

    nf_conntrack_event_cache(master_ct(ct) ? IPCT_RELATED : IPCT_NEW, ct);
    return NF_ACCEPT;
}

ovs就是直接调用nf_conntrack_in和nf_conntrack_confirm进行连接追踪的

///////////////

linux内核如何实现iptables

一是iptables规则下发，控制面可以仍然使用iptables命令，到内核是调用

在Ip_tables.c中，初始化一个nf_sockopt_ops 结构，指定其set操作函数为do_ipt_set_ctl（）方法，get操作函数为do_ipt_get_ctl（）方法，代码如下：

static struct nf_sockopt_ops ipt_sockopts = {
    .pf    = PF_INET,
    .set_optmin   = IPT_BASE_CTL,
    .set_optmax   = IPT_SO_SET_MAX+1,
    .set       = do_ipt_set_ctl,
#ifdef CONFIG_COMPAT
    .compat_set   = compat_do_ipt_set_ctl,
#endif
    .get_optmin   = IPT_BASE_CTL,
    .get_optmax   = IPT_SO_GET_MAX+1,
    .get       = do_ipt_get_ctl,
#ifdef CONFIG_COMPAT
    .compat_get   = compat_do_ipt_get_ctl,
#endif
    .owner     = THIS_MODULE,
};

关于do_ipt_set_ctl()方法的功能和具体实现，我们后面在详细说明。
随后，在模块初始化的时候，调用nf_register_sockopt（）方法，将ipt_sockopts添加到nf_sockopts全局变量中：
/* Register setsockopt */
    ret = nf_register_sockopt(&ipt_sockopts);

static int
do_ipt_set_ctl(struct sock *sk, int cmd, void __user *user, unsigned int len)
{
    int ret;
    if (!capable(CAP_NET_ADMIN))
       return -EPERM;
    switch (cmd) {
    case IPT_SO_SET_REPLACE:
       ret = do_replace(sock_net(sk), user, len);
       break;
    case IPT_SO_SET_ADD_COUNTERS:
       ret = do_add_counters(sock_net(sk), user, len, 0);
       break;
    default:
       duprintf("do_ipt_set_ctl:  unknown request %i\n", cmd);
       ret = -EINVAL;
    }
    return ret;
}

do_replace()方法复制用户空间数据到内核空间，并对其做一些必要检查，然后调用__do_replace()保存到对应的table中：

static int
do_replace(struct net *net, const void __user *user, unsigned int len)
{
    int ret;
    struct ipt_replace tmp;
    struct xt_table_info *newinfo;
    void *loc_cpu_entry;
    struct ipt_entry *iter;
      // 复制用户空间数据到内核
    if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
       return -EFAULT;
    /* overflow check */
    if (tmp.num_counters >= INT_MAX / sizeof(struct xt_counters))
       return -ENOMEM;
    tmp.name[sizeof(tmp.name)-1] = 0;
    newinfo = xt_alloc_table_info(tmp.size);
    if (!newinfo)
       return -ENOMEM;
    /* choose the copy that is on our node/cpu */
    loc_cpu_entry = newinfo->entries[raw_smp_processor_id()];
      // 将用户空间传入的数据中的规则部分复制到newinfo的entries中
    if (copy_from_user(loc_cpu_entry, user + sizeof(tmp),
              tmp.size) != 0) {
       ret = -EFAULT;
       goto free_newinfo;
    }
    // 对用户空间的数据进行检查，同时为每个cpu做一份copy
      ret = translate_table(net, newinfo, loc_cpu_entry, &tmp);
    if (ret != 0)
       goto free_newinfo;
    duprintf("Translated table\n");
      // 查找所属表，将newinfo（包含用户空间提交的规则）替换到对应的表
      // 的数据区中。
    ret = __do_replace(net, tmp.name, tmp.valid_hooks, newinfo,
              tmp.num_counters, tmp.counters);
    if (ret)
       goto free_newinfo_untrans;
    return 0;
 free_newinfo_untrans:
    xt_entry_foreach(iter, loc_cpu_entry, newinfo->size)
       cleanup_entry(iter, net);
 free_newinfo:
    xt_free_table_info(newinfo);
    return ret;
}

https://ipset.netfilter.org/iptables-extensions.man.html

physdev
This module matches on the bridge port input and output devices enslaved to a bridge device. This module is a part of the infrastructure that enables a transparent bridging IP firewall and is only useful for kernel versions above version 2.5.44.

[!] --physdev-in name
Name of a bridge port via which a packet is received (only for packets entering the INPUT, FORWARD and PREROUTING chains). If the interface name ends in a "+", then any interface which begins with this name will match. If the packet didn't arrive through a bridge device, this packet won't match this option, unless '!' is used.
[!] --physdev-out name
Name of a bridge port via which a packet is going to be sent (for bridged packets entering the FORWARD and POSTROUTING chains). If the interface name ends in a "+", then any interface which begins with this name will match.
[!] --physdev-is-in
Matches if the packet has entered through a bridge interface.
[!] --physdev-is-out
Matches if the packet will leave through a bridge interface.
[!] --physdev-is-bridged
Matches if the packet is being bridged and therefore is not being routed. This is only useful in the FORWARD and POSTROUTING chains.

iptables -A FORWARD -m physdev --physdev-is-bridged -j bridgechain
iptables -A bridgechain -m physdev --physdev-in vnet0 --physdev-is-bridged -j vnet0-o
iptables -A brigdechain -m physdev --physdev-out vnet0 --physdev-is-bridged -j vnet0-i


二是转发过程中按iptables规则进行过滤

Netfilter介入到IP协议栈，是通过NF_HOOK

NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
		       net, NULL, skb, dev, NULL,
		       ip_rcv_finish);

NF_HOOK(NFPROTO_IPV4, NF_INET_LOCAL_IN,
		       net, NULL, skb, skb->dev, NULL,
		       ip_local_deliver_finish);

NF_HOOK(NFPROTO_IPV4, NF_INET_FORWARD,
		       net, NULL, skb, skb->dev, rt->dst.dev,
		       ip_forward_finish);

nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT,
		       net, sk, skb, NULL, skb_dst(skb)->dev,
		       dst_output);

NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING,
			    net, sk, skb, NULL, dev,
			    ip_finish_output,
			    !(IPCB(skb)->flags & IPSKB_REROUTED));

static inline int
NF_HOOK_COND(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk,
	     struct sk_buff *skb, struct net_device *in, struct net_device *out,
	     int (*okfn)(struct net *, struct sock *, struct sk_buff *),
	     bool cond)
{
	int ret;

	if (!cond ||
	    ((ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn)) == 1))
		ret = okfn(net, sk, skb);
	return ret;
}

static inline int
NF_HOOK(uint8_t pf, unsigned int hook, struct net *net, struct sock *sk, struct sk_buff *skb,
	struct net_device *in, struct net_device *out,
	int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
	int ret = nf_hook(pf, hook, net, sk, skb, in, out, okfn);
	if (ret == 1)
		ret = okfn(net, sk, skb);
	return ret;
}

/**
 *	nf_hook - call a netfilter hook
 *
 *	Returns 1 if the hook has allowed the packet to pass.  The function
 *	okfn must be invoked by the caller in this case.  Any other return
 *	value indicates the packet has been consumed by the hook.
 */
static inline int nf_hook(u_int8_t pf, unsigned int hook, struct net *net,
			  struct sock *sk, struct sk_buff *skb,
			  struct net_device *indev, struct net_device *outdev,
			  int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
	struct nf_hook_entries *hook_head = NULL;
	int ret = 1;

#ifdef CONFIG_JUMP_LABEL
	if (__builtin_constant_p(pf) &&
	    __builtin_constant_p(hook) &&
	    !static_key_false(&nf_hooks_needed[pf][hook]))
		return 1;
#endif

	rcu_read_lock();
	switch (pf) {
	case NFPROTO_IPV4:
		hook_head = rcu_dereference(net->nf.hooks_ipv4[hook]);
		break;
	case NFPROTO_IPV6:
		hook_head = rcu_dereference(net->nf.hooks_ipv6[hook]);
		break;
	case NFPROTO_ARP:
#ifdef CONFIG_NETFILTER_FAMILY_ARP
		if (WARN_ON_ONCE(hook >= ARRAY_SIZE(net->nf.hooks_arp)))
			break;
		hook_head = rcu_dereference(net->nf.hooks_arp[hook]);
#endif
		break;
	case NFPROTO_BRIDGE:
#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE
		hook_head = rcu_dereference(net->nf.hooks_bridge[hook]);
#endif
		break;
#if IS_ENABLED(CONFIG_DECNET)
	case NFPROTO_DECNET:
		hook_head = rcu_dereference(net->nf.hooks_decnet[hook]);
		break;
#endif
	default:
		WARN_ON_ONCE(1);
		break;
	}

	if (hook_head) {
		struct nf_hook_state state;

		nf_hook_state_init(&state, hook, pf, indev, outdev,
				   sk, net, okfn);

		ret = nf_hook_slow(skb, &state, hook_head, 0);
	}
	rcu_read_unlock();

	return ret;
}

/* Returns 1 if okfn() needs to be executed by the caller,
 * -EPERM for NF_DROP, 0 otherwise.  Caller must hold rcu_read_lock. */
int nf_hook_slow(struct sk_buff *skb, struct nf_hook_state *state,
		 const struct nf_hook_entries *e, unsigned int s)
{
	unsigned int verdict;
	int ret;

	for (; s < e->num_hook_entries; s++) {
		verdict = nf_hook_entry_hookfn(&e->hooks[s], skb, state);
		switch (verdict & NF_VERDICT_MASK) {
		case NF_ACCEPT:
			break;
		case NF_DROP:
			kfree_skb(skb);
			ret = NF_DROP_GETERR(verdict);
			if (ret == 0)
				ret = -EPERM;
			return ret;
		case NF_QUEUE:
			ret = nf_queue(skb, state, s, verdict);
			if (ret == 1)
				continue;
			return ret;
		default:
			/* Implicit handling for NF_STOLEN, as well as any other
			 * non conventional verdicts.
			 */
			return 0;
		}
	}

	return 1;
}

static inline int
nf_hook_entry_hookfn(const struct nf_hook_entry *entry, struct sk_buff *skb,
		     struct nf_hook_state *state)
{
	return entry->hook(entry->priv, skb, state);
}


static struct nf_hook_ops *filter_ops __read_mostly;

static int __init iptable_filter_init(void)
{
	int ret;

	filter_ops = xt_hook_ops_alloc(&packet_filter, iptable_filter_hook);
	if (IS_ERR(filter_ops))
		return PTR_ERR(filter_ops);

	ret = register_pernet_subsys(&iptable_filter_net_ops);
	if (ret < 0)
		kfree(filter_ops);

	return ret;
}

#define FILTER_VALID_HOOKS ((1 << NF_INET_LOCAL_IN) | \
			    (1 << NF_INET_FORWARD) | \
			    (1 << NF_INET_LOCAL_OUT))

static const struct xt_table packet_filter = {
	.name		= "filter",
	.valid_hooks	= FILTER_VALID_HOOKS,
	.me		= THIS_MODULE,
	.af		= NFPROTO_IPV4,
	.priority	= NF_IP_PRI_FILTER,
	.table_init	= iptable_filter_table_init,
};

static unsigned int
iptable_filter_hook(void *priv, struct sk_buff *skb,
		    const struct nf_hook_state *state)
{
	return ipt_do_table(skb, state, state->net->ipv4.iptable_filter);
}

struct nf_hook_state {
	unsigned int hook;
	u_int8_t pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

ovs里面调用netfilter conntrack的时候，自己构建了一个 nf_hook_state

所以iptables得数据面执行在ipt_do_table函数中

/**
 * struct datapath - datapath for flow-based packet switching
 * @rcu: RCU callback head for deferred destruction.
 * @list_node: Element in global 'dps' list.
 * @table: Current flow table.  Protected by ovs_mutex and RCU.
 * @ports: Hash table for ports.  %OVSP_LOCAL port always exists.  Protected by
 * ovs_mutex and RCU.
 * @stats_percpu: Per-CPU datapath statistics.
 * @net: Reference to net namespace.
 *
 * Context: See the comment on locking at the top of datapath.c for additional
 * locking information.
 */
struct datapath {
	struct rcu_head rcu;
	struct list_head list_node;

	/* Flow table. */
	struct flow_table __rcu *table;

	/* Switch ports. */
	struct hlist_head *ports;

	/* Stats. */
	struct dp_stats_percpu __percpu *stats_percpu;

#ifdef CONFIG_NET_NS
	/* Network namespace ref. */
	struct net *net;
#endif
};

static inline struct net *ovs_dp_get_net(const struct datapath *dp)
{
	return rpl_read_pnet(&dp->net);
}

static inline void ovs_dp_set_net(struct datapath *dp, struct net *net)
{
	rpl_write_pnet(&dp->net, net);
}

static inline void nf_hook_state_init(struct nf_hook_state *p,
				      unsigned int hook,
				      u_int8_t pf,
				      struct net_device *indev,
				      struct net_device *outdev,
				      struct sock *sk,
				      struct net *net,
				      int (*okfn)(struct net *, struct sock *, struct sk_buff *))
{
	p->hook = hook;
	p->pf = pf;
	p->in = indev;
	p->out = outdev;
	p->sk = sk;
	p->net = net;
	p->okfn = okfn;
}

//////////////////////////基于ovs的security group流表

root@devstack-compute:~# ovs-ofctl dump-flows br-int
 cookie=0x7743891425658ece, duration=846046.156s, table=0, n_packets=0, n_bytes=0, priority=65535,dl_vlan=4095 actions=drop
 cookie=0x7743891425658ece, duration=846045.127s, table=0, n_packets=0, n_bytes=0, priority=2,in_port="int-br-ex" actions=drop
 cookie=0x7743891425658ece, duration=846046.158s, table=0, n_packets=73461, n_bytes=7039447, priority=0 actions=resubmit(,60)
 cookie=0x7743891425658ece, duration=846046.159s, table=23, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=846046.156s, table=24, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=18.718s, table=60, n_packets=6134, n_bytes=461249, priority=100,in_port="tap2153195f-07" actions=load:0x9->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],resubmit(,71)
 cookie=0x7743891425658ece, duration=18.675s, table=60, n_packets=26728, n_bytes=2507274, priority=100,in_port="tap6fe8c0dc-3c" actions=load:0xa->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],resubmit(,71)
 cookie=0x7743891425658ece, duration=18.635s, table=60, n_packets=2115, n_bytes=182075, priority=100,in_port="tapc525eeb9-c4" actions=load:0xd->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],resubmit(,71)
 cookie=0x7743891425658ece, duration=18.718s, table=60, n_packets=4679, n_bytes=330519, priority=90,dl_vlan=4,dl_dst=fa:16:3e:9d:3d:e6 actions=load:0x9->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],strip_vlan,resubmit(,81)
 cookie=0x7743891425658ece, duration=18.675s, table=60, n_packets=23181, n_bytes=2203625, priority=90,dl_vlan=4,dl_dst=fa:16:3e:ec:55:08 actions=load:0xa->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],strip_vlan,resubmit(,81)
 cookie=0x7743891425658ece, duration=18.635s, table=60, n_packets=126, n_bytes=18642, priority=90,dl_vlan=4,dl_dst=fa:16:3e:e6:20:df actions=load:0xd->NXM_NX_REG5[],load:0x4->NXM_NX_REG6[],strip_vlan,resubmit(,81)
 cookie=0x7743891425658ece, duration=846046.157s, table=60, n_packets=9868, n_bytes=1272905, priority=3 actions=NORMAL
 cookie=0x7743891425658ece, duration=846046.155s, table=62, n_packets=0, n_bytes=0, priority=3 actions=NORMAL
 cookie=0x7743891425658ece, duration=846042.868s, table=71, n_packets=0, n_bytes=0, priority=110,ct_state=+trk actions=ct_clear,resubmit(,71)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=2400, n_bytes=100800, priority=95,arp,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,arp_spa=10.0.0.8 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=3665, n_bytes=351307, priority=65,ip,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,nw_src=10.0.0.8 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=1334, n_bytes=56028, priority=95,arp,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,arp_spa=10.0.0.14 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=21827, n_bytes=2138850, priority=65,ip,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,nw_src=10.0.0.14 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=14, n_bytes=588, priority=95,arp,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,arp_spa=10.0.0.20 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=162, n_bytes=13709, priority=65,ip,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,nw_src=10.0.0.20 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fe80::f816:3eff:fe9d:3de6,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=6, n_bytes=420, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fe80::f816:3eff:fe9d:3de6,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=2, n_bytes=172, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fe80::f816:3eff:fe9d:3de6,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fe80::f816:3eff:feec:5508,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fe80::f816:3eff:feec:5508,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=3545, n_bytes=304870, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fe80::f816:3eff:feec:5508,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fe80::f816:3eff:fee6:20df,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fe80::f816:3eff:fee6:20df,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=1935, n_bytes=166410, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fe80::f816:3eff:fee6:20df,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df,icmp_type=130 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df,icmp_type=133 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df,icmp_type=135 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",icmp_type=136,nd_target=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=2, n_bytes=156, priority=95,icmp6,reg5=0x9,in_port="tap2153195f-07",icmp_type=136,nd_target=fe80::f816:3eff:fe9d:3de6 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",icmp_type=136,nd_target=fd39:e6ea:4b0b:0:f816:3eff:feec:5508 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",icmp_type=136,nd_target=fe80::f816:3eff:feec:5508 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",icmp_type=136,nd_target=fe80::f816:3eff:fee6:20df actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=95,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",icmp_type=136,nd_target=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=14, n_bytes=4788, priority=80,udp,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,nw_src=10.0.0.8,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=4, n_bytes=1368, priority=80,udp,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,nw_src=0.0.0.0,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=18, n_bytes=6156, priority=80,udp,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,nw_src=10.0.0.14,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=4, n_bytes=1370, priority=80,udp,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,nw_src=0.0.0.0,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=4, n_bytes=1368, priority=80,udp,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,nw_src=10.0.0.20,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=80,udp,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,nw_src=0.0.0.0,tp_src=68,tp_dst=67 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fe80::f816:3eff:fe9d:3de6,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fe80::f816:3eff:feec:5508,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fe80::f816:3eff:fee6:20df,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=80,udp6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df,tp_src=546,tp_dst=547 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=70,udp,reg5=0x9,in_port="tap2153195f-07",tp_src=67,tp_dst=68 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=70,udp6,reg5=0x9,in_port="tap2153195f-07",tp_src=547,tp_dst=546 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=70,udp,reg5=0xa,in_port="tap6fe8c0dc-3c",tp_src=67,tp_dst=68 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=70,udp6,reg5=0xa,in_port="tap6fe8c0dc-3c",tp_src=547,tp_dst=546 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=70,udp,reg5=0xd,in_port="tapc525eeb9-c4",tp_src=67,tp_dst=68 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=70,udp6,reg5=0xd,in_port="tapc525eeb9-c4",tp_src=547,tp_dst=546 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=70,icmp6,reg5=0x9,in_port="tap2153195f-07",icmp_type=134 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=70,icmp6,reg5=0xa,in_port="tap6fe8c0dc-3c",icmp_type=134 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=70,icmp6,reg5=0xd,in_port="tapc525eeb9-c4",icmp_type=134 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=0, n_bytes=0, priority=65,ipv6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=4, n_bytes=360, priority=65,ipv6,reg5=0x9,in_port="tap2153195f-07",dl_src=fa:16:3e:9d:3d:e6,ipv6_src=fe80::f816:3eff:fe9d:3de6 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=65,ipv6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=65,ipv6,reg5=0xa,in_port="tap6fe8c0dc-3c",dl_src=fa:16:3e:ec:55:08,ipv6_src=fe80::f816:3eff:feec:5508 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=65,ipv6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fe80::f816:3eff:fee6:20df actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=65,ipv6,reg5=0xd,in_port="tapc525eeb9-c4",dl_src=fa:16:3e:e6:20:df,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df actions=ct(table=72,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.718s, table=71, n_packets=37, n_bytes=1878, priority=10,reg5=0x9,in_port="tap2153195f-07" actions=ct_clear,resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=71, n_packets=0, n_bytes=0, priority=10,reg5=0xa,in_port="tap6fe8c0dc-3c" actions=ct_clear,resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=71, n_packets=0, n_bytes=0, priority=10,reg5=0xd,in_port="tapc525eeb9-c4" actions=ct_clear,resubmit(,93)
 cookie=0x7743891425658ece, duration=846042.890s, table=71, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0x9,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xa,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xd,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0x9,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xa,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xd,tp_dst=5555 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+est-rel-rpl,ipv6,reg5=0x9 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=137, n_bytes=13663, priority=74,ct_state=+est-rel-rpl,ip,reg5=0x9 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+est-rel-rpl,ipv6,reg5=0xa actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=21816, n_bytes=2137896, priority=74,ct_state=+est-rel-rpl,ip,reg5=0xa actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+est-rel-rpl,ipv6,reg5=0xd actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=135, n_bytes=11711, priority=74,ct_state=+est-rel-rpl,ip,reg5=0xd actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+new-est,ipv6,reg5=0x9 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=3048, n_bytes=271317, priority=74,ct_state=+new-est,ip,reg5=0x9 actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+new-est,ipv6,reg5=0xa actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=11, n_bytes=954, priority=74,ct_state=+new-est,ip,reg5=0xa actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=74,ct_state=+new-est,ipv6,reg5=0xd actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=27, n_bytes=1998, priority=74,ct_state=+new-est,ip,reg5=0xd actions=resubmit(,73)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=10, n_bytes=900, priority=50,ct_state=+inv+trk actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0x9 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0xa actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0xd actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=480, n_bytes=66327, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0x9 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0xa actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0xd actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0x9 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0xa actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0xd actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0x9 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0xa actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0xd actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.718s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.675s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.635s, table=72, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=846042.886s, table=72, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=18.718s, table=73, n_packets=0, n_bytes=0, priority=100,reg6=0x4,dl_dst=fa:16:3e:9d:3d:e6 actions=load:0x9->NXM_NX_REG5[],resubmit(,81)
 cookie=0x7743891425658ece, duration=18.675s, table=73, n_packets=0, n_bytes=0, priority=100,reg6=0x4,dl_dst=fa:16:3e:ec:55:08 actions=load:0xa->NXM_NX_REG5[],resubmit(,81)
 cookie=0x7743891425658ece, duration=18.635s, table=73, n_packets=0, n_bytes=0, priority=100,reg6=0x4,dl_dst=fa:16:3e:e6:20:df actions=load:0xd->NXM_NX_REG5[],resubmit(,81)
 cookie=0x7743891425658ece, duration=18.718s, table=73, n_packets=3048, n_bytes=271317, priority=90,ct_state=+new-est,ip,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.718s, table=73, n_packets=0, n_bytes=0, priority=90,ct_state=+new-est,ipv6,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.675s, table=73, n_packets=11, n_bytes=954, priority=90,ct_state=+new-est,ip,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.675s, table=73, n_packets=0, n_bytes=0, priority=90,ct_state=+new-est,ipv6,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.635s, table=73, n_packets=27, n_bytes=1998, priority=90,ct_state=+new-est,ip,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.635s, table=73, n_packets=0, n_bytes=0, priority=90,ct_state=+new-est,ipv6,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),resubmit(,91)
 cookie=0x7743891425658ece, duration=18.718s, table=73, n_packets=155, n_bytes=19819, priority=80,reg5=0x9 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.675s, table=73, n_packets=21838, n_bytes=2145422, priority=80,reg5=0xa actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=18.635s, table=73, n_packets=139, n_bytes=13079, priority=80,reg5=0xd actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=846042.881s, table=73, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=2400, n_bytes=100800, priority=100,arp,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=1334, n_bytes=56028, priority=100,arp,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=14, n_bytes=588, priority=100,arp,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0x9,icmp_type=130 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=2, n_bytes=172, priority=100,icmp6,reg5=0x9,icmp_type=135 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=2, n_bytes=156, priority=100,icmp6,reg5=0x9,icmp_type=136 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xa,icmp_type=130 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xa,icmp_type=135 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xa,icmp_type=136 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xd,icmp_type=130 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xd,icmp_type=135 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=100,icmp6,reg5=0xd,icmp_type=136 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=18, n_bytes=6915, priority=95,udp,reg5=0x9,tp_src=67,tp_dst=68 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=0, n_bytes=0, priority=95,udp6,reg5=0x9,tp_src=547,tp_dst=546 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=22, n_bytes=8460, priority=95,udp,reg5=0xa,tp_src=67,tp_dst=68 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=95,udp6,reg5=0xa,tp_src=547,tp_dst=546 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=4, n_bytes=1544, priority=95,udp,reg5=0xd,tp_src=67,tp_dst=68 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=95,udp6,reg5=0xd,tp_src=547,tp_dst=546 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=2251, n_bytes=221624, priority=90,ct_state=-trk,ip,reg5=0x9 actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=6, n_bytes=852, priority=90,ct_state=-trk,ipv6,reg5=0x9 actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=21825, n_bytes=2139137, priority=90,ct_state=-trk,ip,reg5=0xa actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=90,ct_state=-trk,ipv6,reg5=0xa actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=108, n_bytes=16510, priority=90,ct_state=-trk,ip,reg5=0xd actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=90,ct_state=-trk,ipv6,reg5=0xd actions=ct(table=82,zone=NXM_NX_REG6[0..15])
 cookie=0x7743891425658ece, duration=18.718s, table=81, n_packets=0, n_bytes=0, priority=80,ct_state=+trk,reg5=0x9 actions=resubmit(,82)
 cookie=0x7743891425658ece, duration=18.675s, table=81, n_packets=0, n_bytes=0, priority=80,ct_state=+trk,reg5=0xa actions=resubmit(,82)
 cookie=0x7743891425658ece, duration=18.635s, table=81, n_packets=0, n_bytes=0, priority=80,ct_state=+trk,reg5=0xd actions=resubmit(,82)
 cookie=0x7743891425658ece, duration=846042.877s, table=81, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=3, n_bytes=294, priority=75,ct_state=+est-rel-rpl,icmp,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=744, n_bytes=79682, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,udp,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+est-rel-rpl,icmp,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,udp,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+est-rel-rpl,icmp,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,udp,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=2, n_bytes=196, priority=75,ct_state=+new-est,icmp,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=7, n_bytes=518, priority=77,ct_state=+new-est,tcp,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,udp,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+new-est,icmp,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,udp,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=75,ct_state=+new-est,icmp,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,udp,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0x9,tp_dst=4444 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xa,tp_dst=4444 actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+est-rel-rpl,tcp,reg5=0xd,tp_dst=4444 actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0x9,tp_dst=4444 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xa,tp_dst=4444 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=77,ct_state=+new-est,tcp,reg5=0xd,tp_dst=4444 actions=ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0x9 actions=conjunction(16,2/2)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg5=0x9 actions=conjunction(24,2/2)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0xa actions=conjunction(16,2/2)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xa actions=conjunction(24,2/2)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0xd actions=conjunction(16,2/2)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xd actions=conjunction(24,2/2)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg5=0x9 actions=conjunction(17,2/2)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg5=0x9 actions=conjunction(25,2/2)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg5=0xa actions=conjunction(17,2/2)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg5=0xa actions=conjunction(25,2/2)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg5=0xd actions=conjunction(17,2/2)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg5=0xd actions=conjunction(25,2/2)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=16,ct_state=+est-rel-rpl,ipv6,reg5=0x9 actions=load:0x10->NXM_NX_REG7[],output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=24,ct_state=+est-rel-rpl,ip,reg5=0x9 actions=load:0x18->NXM_NX_REG7[],output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=16,ct_state=+est-rel-rpl,ipv6,reg5=0xa actions=load:0x10->NXM_NX_REG7[],output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=24,ct_state=+est-rel-rpl,ip,reg5=0xa actions=load:0x18->NXM_NX_REG7[],output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=16,ct_state=+est-rel-rpl,ipv6,reg5=0xd actions=load:0x10->NXM_NX_REG7[],output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=24,ct_state=+est-rel-rpl,ip,reg5=0xd actions=load:0x18->NXM_NX_REG7[],output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=17,ct_state=+new-est,ipv6,reg5=0x9 actions=load:0x11->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=25,ct_state=+new-est,ip,reg5=0x9 actions=load:0x19->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap2153195f-07",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=17,ct_state=+new-est,ipv6,reg5=0xa actions=load:0x11->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=25,ct_state=+new-est,ip,reg5=0xa actions=load:0x19->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tap6fe8c0dc-3c",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=17,ct_state=+new-est,ipv6,reg5=0xd actions=load:0x11->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=70,conj_id=25,ct_state=+new-est,ip,reg5=0xd actions=load:0x19->NXM_NX_REG7[],ct(commit,zone=NXM_NX_REG6[0..15]),output:"tapc525eeb9-c4",resubmit(,92)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6 actions=conjunction(16,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508 actions=conjunction(16,1/2)
 cookie=0xd080abf658564940, duration=179633.464s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df actions=conjunction(16,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fe9d:3de6 actions=conjunction(17,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:feec:5508 actions=conjunction(17,1/2)
 cookie=0xd080abf658564940, duration=179633.464s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ipv6,reg6=0x4,ipv6_src=fd39:e6ea:4b0b:0:f816:3eff:fee6:20df actions=conjunction(17,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg6=0x4,nw_src=10.0.0.8 actions=conjunction(24,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg6=0x4,nw_src=10.0.0.14 actions=conjunction(24,1/2)
 cookie=0xd080abf658564940, duration=179633.464s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+est-rel-rpl,ip,reg6=0x4,nw_src=10.0.0.20 actions=conjunction(24,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg6=0x4,nw_src=10.0.0.8 actions=conjunction(25,1/2)
 cookie=0x7743891425658ece, duration=493602.147s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg6=0x4,nw_src=10.0.0.14 actions=conjunction(25,1/2)
 cookie=0xd080abf658564940, duration=179633.464s, table=82, n_packets=0, n_bytes=0, priority=70,ct_state=+new-est,ip,reg6=0x4,nw_src=10.0.0.20 actions=conjunction(25,1/2)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=15, n_bytes=2130, priority=50,ct_state=+inv+trk actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0x9 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0xa actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=50,ct_mark=0x1,reg5=0xd actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=1463, n_bytes=137568, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=21825, n_bytes=2139137, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=108, n_bytes=16510, priority=50,ct_state=+est-rel+rpl,ct_zone=4,ct_mark=0,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=13, n_bytes=1504, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0x9 actions=output:"tap2153195f-07"
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0xa actions=output:"tap6fe8c0dc-3c"
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=50,ct_state=-new-est+rel-inv,ct_zone=4,ct_mark=0,reg5=0xd actions=output:"tapc525eeb9-c4"
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=19, n_bytes=1862, priority=40,ct_state=-est,reg5=0x9 actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0xa actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=-est,reg5=0xd actions=resubmit(,93)
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.718s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0x9 actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.675s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ip,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=18.635s, table=82, n_packets=0, n_bytes=0, priority=40,ct_state=+est,ipv6,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
 cookie=0x7743891425658ece, duration=846042.873s, table=82, n_packets=0, n_bytes=0, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=846042.859s, table=91, n_packets=3213, n_bytes=284889, priority=1 actions=resubmit(,94)
 cookie=0x7743891425658ece, duration=846042.855s, table=92, n_packets=9, n_bytes=714, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=846042.850s, table=93, n_packets=94, n_bytes=7824, priority=0 actions=drop
 cookie=0x7743891425658ece, duration=846042.864s, table=94, n_packets=35336, n_bytes=3185191, priority=1 actions=NORMAL



ovs conntrack based firewall driver (by quqi99)

( http://blog.csdn.net/quqi99 )
我们知道，Neutron security group特性是基于iptables实现的，iptables规则只能作用于linux bridge，不能作用于ovs bridge上，所以在VM port和ovs br-int之前又多弄了一个linux bridge (qbr-xxx)，这会极大影响性能。如今openvswitch 2.5 （需使用linux kernel 4.3+) （sudo add-apt-repository cloud-archive:mitaka && sudo apt-get install openvswitch-switch）已经支持conntract特性，neutron也在Mitaka中实现了这一特性[1]. 创建两个虚机之后查看它的流表如下，解释见内联注释。

cookie=0xb7d7ed46110fd50e, duration=10510.153s, table=0, n_packets=6, n_bytes=582, idle_age=886, priority=2,in_port=1 actions=drop

# Table 0是分类表，reg5用于存储port_id (出口流量使用port_id标识，入口流量采用mac_address标识。出口与入口以虚机为基准）, reg6用于存储zone避免不同的port可能出现conntrack参数相同的情况。出口流量转到table 71, 入口流量转到table 81
cookie=0xb7d7ed46110fd50e, duration=10155.140s, table=0, n_packets=25, n_bytes=2332, idle_age=9619, priority=100,in_port=13 actions=load:0xd->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],resubmit(,71)
cookie=0xb7d7ed46110fd50e, duration=10155.041s, table=0, n_packets=97, n_bytes=12752, idle_age=9617, priority=100,in_port=10 actions=load:0xa->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],resubmit(,71)
cookie=0xb7d7ed46110fd50e, duration=10155.140s, table=0, n_packets=12, n_bytes=1489, idle_age=10143, priority=90,dl_dst=fa:16:3e:e9:f9:c8 actions=load:0xd->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],resubmit(,81)
cookie=0xb7d7ed46110fd50e, duration=10155.040s, table=0, n_packets=118, n_bytes=21821, idle_age=9617, priority=90,dl_dst=fa:16:3e:5c:25:9d actions=load:0xa->NXM_NX_REG5[],load:0x1->NXM_NX_REG6[],resubmit(,81)

# 对从int-br-phy (在br-int与br-phy中的一个ovs patch port)进br-int的入虚机流量将vlan 1053换成local vlan 1.
cookie=0xb7d7ed46110fd50e, duration=10447.209s, table=0, n_packets=0, n_bytes=0, idle_age=10447, priority=3,in_port=1,dl_vlan=1053 actions=mod_vlan_vid:1,NORMAL
cookie=0xb7d7ed46110fd50e, duration=10510.260s, table=0, n_packets=19, n_bytes=1554, idle_age=10383, priority=0 actions=NORMAL


cookie=0xb7d7ed46110fd50e, duration=10510.252s, table=23, n_packets=0, n_bytes=0, idle_age=10510, priority=0 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10510.244s, table=24, n_packets=0, n_bytes=0, idle_age=10510, priority=0 actions=drop


# Allow ICMPv6 traffic for multicast listeners, neighbour solicitation and neighbour advertisement for egress flow.
cookie=0xb7d7ed46110fd50e, duration=10155.140s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xd,in_port=13,icmp_type=130 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.140s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xd,in_port=13,icmp_type=131 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.139s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xd,in_port=13,icmp_type=132 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.139s, table=71, n_packets=1, n_bytes=78, idle_age=10147, priority=95,icmp6,reg5=0xd,in_port=13,icmp_type=135 actions=NORMAL


cookie=0xb7d7ed46110fd50e, duration=10155.139s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xd,in_port=13,icmp_type=136 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.040s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xa,in_port=10,icmp_type=130 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xa,in_port=10,icmp_type=131 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xa,in_port=10,icmp_type=132 actions=NORMAL


cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xa,in_port=10,icmp_type=135 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=95,icmp6,reg5=0xa,in_port=10,icmp_type=136 actions=NORMAL

# 在table 71中对出虚机的流量做arp spoofing protection
cookie=0xb7d7ed46110fd50e, duration=10155.139s, table=71, n_packets=7, n_bytes=294, idle_age=9619, priority=95,arp,reg5=0xd,in_port=13,dl_src=fa:16:3e:e9:f9:c8,arp_spa=10.0.1.8 actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=7, n_bytes=294, idle_age=9617, priority=95,arp,reg5=0xa,in_port=10,dl_src=fa:16:3e:5c:25:9d,arp_spa=10.0.1.7 actions=NORMAL

# 充许端口为68,67, 546, 547(dhcp, dhcpv6, slaas, ndp)的流量出虚机, but DHCP servers are blocked on instances.
cookie=0xb7d7ed46110fd50e, duration=10155.138s, table=71, n_packets=2, n_bytes=668, idle_age=10148, priority=80,udp,reg5=0xd,in_port=13,tp_src=68,tp_dst=67 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.138s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=80,udp6,reg5=0xd,in_port=13,tp_src=546,tp_dst=547 actions=resubmit(,73)


cookie=0xb7d7ed46110fd50e, duration=10155.137s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=70,udp,reg5=0xd,in_port=13,tp_src=67,tp_dst=68 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.137s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=70,udp6,reg5=0xd,in_port=13,tp_src=547,tp_dst=546 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.038s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=80,udp,reg5=0xa,in_port=10,tp_src=68,tp_dst=67 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.038s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=80,udp6,reg5=0xa,in_port=10,tp_src=546,tp_dst=547 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.037s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=70,udp,reg5=0xa,in_port=10,tp_src=67,tp_dst=68 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.037s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=70,udp6,reg5=0xa,in_port=10,tp_src=547,tp_dst=546 actions=drop


# 对-trk状态的出虚机流量转到table 72继续处理，并使用ip+mac从内核的conntrack中获取conntrack的相关信息，drop其他流量
cookie=0xb7d7ed46110fd50e, duration=10155.138s, table=71, n_packets=10, n_bytes=902, idle_age=9619, priority=65,ct_state=-trk,ip,reg5=0xd,in_port=13,dl_src=fa:16:3e:e9:f9:c8,nw_src=10.0.1.8 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.039s, table=71, n_packets=90, n_bytes=12458, idle_age=9619, priority=65,ct_state=-trk,ip,reg5=0xa,in_port=10,dl_src=fa:16:3e:5c:25:9d,nw_src=10.0.1.7 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.138s, table=71, n_packets=4, n_bytes=300, idle_age=10138, priority=65,ct_state=-trk,ipv6,reg5=0xd,in_port=13,dl_src=fa:16:3e:e9:f9:c8,ipv6_src=fe80::f816:3eff:fee9:f9c8 actions=ct(table=72,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.038s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=65,ct_state=-trk,ipv6,reg5=0xa,in_port=10,dl_src=fa:16:3e:5c:25:9d,ipv6_src=fe80::f816:3eff:fe5c:259d actions=ct(table=72,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.136s, table=71, n_packets=1, n_bytes=90, idle_age=10148, priority=10,ct_state=-trk,reg5=0xd,in_port=13 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.037s, table=71, n_packets=0, n_bytes=0, idle_age=10155, priority=10,ct_state=-trk,reg5=0xa,in_port=10 actions=drop
cookie=0xb7d7ed46110fd50e, duration=10509.934s, table=71, n_packets=0, n_bytes=0, idle_age=10509, priority=0 actions=drop

# tables 72表接受established (est-rel-rpl) or related (-new-est+rel-inv, +est-rel+rpl) or new (new-est)状态的出虚机流量, drop掉invalid (inv+trk, ct_mark=0x1)状态的流量.并且这里实现用户自定义的security group规则。
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0xd,dl_src=fa:16:3e:e9:f9:c8 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xd,dl_src=fa:16:3e:e9:f9:c8 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.029s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ipv6,reg5=0xa,dl_src=fa:16:3e:5c:25:9d actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xa,dl_src=fa:16:3e:5c:25:9d actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=72, n_packets=4, n_bytes=300, idle_age=10138,
priority=70,ct_state=+new-est,ipv6,reg5=0xd,dl_src=fa:16:3e:e9:f9:c8 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=72, n_packets=7, n_bytes=608, idle_age=10148, priority=70,ct_state=+new-est,ip,reg5=0xd,dl_src=fa:16:3e:e9:f9:c8 actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.029s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+new-est,ipv6,reg5=0xa,dl_src=fa:16:3e:5c:25:9d actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=72, n_packets=3, n_bytes=294, idle_age=9619, priority=70,ct_state=+new-est,ip,reg5=0xa,dl_src=fa:16:3e:5c:25:9d actions=resubmit(,73)
cookie=0xb7d7ed46110fd50e, duration=10155.031s, table=72, n_packets=0, n_bytes=0, idle_age=10155,
priority=50,ct_state=+inv+trk actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.131s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_mark=0x1,reg5=0xd actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.031s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_mark=0x1,reg5=0xa actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.131s, table=72, n_packets=3, n_bytes=294, idle_age=9619, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0xd actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.031s, table=72, n_packets=87, n_bytes=12164, idle_age=9619, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0xa actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.130s, table=72, n_packets=0, n_bytes=0, idle_age=10155,
priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0xd actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.030s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0xa actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.130s, table=72, n_packets=0, n_bytes=0, idle_age=10155,
priority=40,ct_state=-est,reg5=0xd actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.130s, table=72, n_packets=0, n_bytes=0, idle_age=10155,

# In the following flows are marked established connections that weren’t matched in the previous flows, which means they don’t have accepting security group rule anymore.
priority=40,ct_state=+est,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
cookie=0xb7d7ed46110fd50e, duration=10155.030s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=-est,reg5=0xa actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.030s, table=72, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=+est,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
cookie=0xb7d7ed46110fd50e, duration=10509.925s, table=72, n_packets=0, n_bytes=0, idle_age=10509, priority=0 actions=drop

# 处理入口流量
cookie=0xb7d7ed46110fd50e, duration=10155.136s, table=73, n_packets=3, n_bytes=294, idle_age=9619, priority=100,dl_dst=fa:16:3e:e9:f9:c8 actions=load:0xd->NXM_NX_REG5[],resubmit(,81)
cookie=0xb7d7ed46110fd50e, duration=10155.037s, table=73, n_packets=0, n_bytes=0, idle_age=10155, priority=100,dl_dst=fa:16:3e:5c:25:9d actions=load:0xa->NXM_NX_REG5[],resubmit(,81)
cookie=0xb7d7ed46110fd50e, duration=10155.136s, table=73, n_packets=11, n_bytes=908, idle_age=10138, priority=90,ct_state=+new-est,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15]),NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.036s, table=73, n_packets=0, n_bytes=0, idle_age=10155, priority=90,ct_state=+new-est,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15]),NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.136s, table=73, n_packets=2, n_bytes=668, idle_age=10148, priority=80,reg5=0xd actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10155.036s, table=73, n_packets=0, n_bytes=0, idle_age=10155, priority=80,reg5=0xa actions=NORMAL
cookie=0xb7d7ed46110fd50e, duration=10509.917s, table=73, n_packets=0, n_bytes=0, idle_age=10509, priority=0 actions=drop

# Table 81 is for ingress traffic, accepts arp response, icmp6 response and udp response.
cookie=0xb7d7ed46110fd50e, duration=10155.135s, table=81, n_packets=3, n_bytes=126, idle_age=10143, priority=100,arp,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.035s, table=81, n_packets=3, n_bytes=126, idle_age=9617, priority=100,arp,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.135s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,icmp_type=130 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.135s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,icmp_type=131 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.135s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,icmp_type=132 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.135s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,icmp_type=135 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.134s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,icmp_type=136 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.035s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,icmp_type=130 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.035s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,icmp_type=131 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.034s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,icmp_type=132 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.033s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,icmp_type=135 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.033s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=100,icmp6,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,icmp_type=136 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.133s, table=81, n_packets=2, n_bytes=755, idle_age=10148,
priority=95,udp,reg5=0xd,tp_src=67,tp_dst=68 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.133s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=95,udp6,reg5=0xd,tp_src=547,tp_dst=546 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.033s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=95,udp,reg5=0xa,tp_src=67,tp_dst=68 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.033s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=95,udp6,reg5=0xa,tp_src=547,tp_dst=546 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.133s, table=81, n_packets=7, n_bytes=608, idle_age=10148,

# Table 81 is for ingress traffic, indentifies not tracked ingress connections.
priority=90,ct_state=-trk,ip,reg5=0xd actions=ct(table=82,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.133s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=90,ct_state=-trk,ipv6,reg5=0xd actions=ct(table=82,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.033s, table=81, n_packets=115, n_bytes=21695, idle_age=9619, priority=90,ct_state=-trk,ip,reg5=0xa actions=ct(table=82,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=90,ct_state=-trk,ipv6,reg5=0xa actions=ct(table=82,zone=NXM_NX_REG6[0..15])
cookie=0xb7d7ed46110fd50e, duration=10155.132s, table=81, n_packets=3, n_bytes=294, idle_age=9619, priority=80,ct_state=+trk,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=resubmit(,82)
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=81, n_packets=0, n_bytes=0, idle_age=10155, priority=80,ct_state=+trk,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=resubmit(,82)
cookie=0xb7d7ed46110fd50e, duration=10509.910s, table=81, n_packets=0, n_bytes=0, idle_age=10509, priority=0 actions=drop

# Table 82接受new (new-est) and established (est-rel-rpl, +est) and related (est-rel+rpl, -new-est+rel-inv)状态的入口流量. 也包括用户自定义的一些流量，如 (nova secgroup-add-rule default icmp -1 -1 0.0.0.0/0).
cookie=0xb7d7ed46110fd50e, duration=10155.130s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,tcp,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,tp_dst=0x16/0xfffe actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.030s, table=82, n_packets=112, n_bytes=21473, idle_age=9619, priority=70,ct_state=+est-rel-rpl,tcp,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,tp_dst=0x16/0xfffe actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.130s, table=82, n_packets=0, n_bytes=0, idle_age=10155,
priority=70,ct_state=+new-est,tcp,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,tp_dst=0x16/0xfffe actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.030s, table=82, n_packets=3, n_bytes=222, idle_age=9622, priority=70,ct_state=+new-est,tcp,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,tp_dst=0x16/0xfffe actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=82, n_packets=0, n_bytes=0, idle_age=10155,
priority=70,ct_state=+est-rel-rpl,icmp,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,icmp,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.129s, table=82, n_packets=3, n_bytes=294, idle_age=9619, priority=70,ct_state=+new-est,icmp,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+new-est,icmp,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.128s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,nw_src=10.0.1.7 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+est-rel-rpl,ip,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,nw_src=10.0.1.8 actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.128s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+new-est,ip,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8,nw_src=10.0.1.7 actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.028s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=70,ct_state=+new-est,ip,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d,nw_src=10.0.1.8 actions=ct(commit,zone=NXM_NX_REG6[0..15]),strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.132s, table=82, n_packets=7, n_bytes=608, idle_age=10148, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_state=+est-rel+rpl,ct_zone=1,ct_mark=0,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.132s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0xd,dl_dst=fa:16:3e:e9:f9:c8 actions=strip_vlan,output:13
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_state=-new-est+rel-inv,ct_zone=1,ct_mark=0,reg5=0xa,dl_dst=fa:16:3e:5c:25:9d actions=strip_vlan,output:10
cookie=0xb7d7ed46110fd50e, duration=10155.131s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=-est,reg5=0xd actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.131s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=+est,reg5=0xd actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=-est,reg5=0xa actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.031s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=40,ct_state=+est,reg5=0xa actions=ct(commit,zone=NXM_NX_REG6[0..15],exec(load:0x1->NXM_NX_CT_MARK[]))

# Table 82 accepts drops invalid ingress connections.
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_state=+inv+trk actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.132s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_mark=0x1,reg5=0xd actions=drop
cookie=0xb7d7ed46110fd50e, duration=10155.032s, table=82, n_packets=0, n_bytes=0, idle_age=10155, priority=50,ct_mark=0x1,reg5=0xa actions=drop
cookie=0xb7d7ed46110fd50e, duration=10509.902s, table=82, n_packets=0, n_bytes=0, idle_age=10509, priority=0 actions=drop

[1] https://review.openstack.org/#/c/302766/