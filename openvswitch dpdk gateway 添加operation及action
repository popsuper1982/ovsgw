openvswitch dpdk gateway 添加operation及action

///////////////

git clone git@github.com:popsuper1982/ovsgw.git
wget https://fast.dpdk.org/rel/dpdk-19.11.2.tar.xz
yum install wget git gcc autoconf automake libtool make pkg-config uuid kernel-devel
yum install numactl-devel
yum install openssl-devel.x86_64
yum install libcap-ng-devel.x86_64

openvswitch-2.14.1.tar.gz
dpdk-19.11.2.tar.xz

tar xvzf openvswitch-2.14.1.tar.gz
tar vxf dpdk-19.11.2.tar.xz

///////////////先不修改编译一遍

创建common文件

export DPDK_DIR=/root/OVSGW/dpdk-stable-19.11.2
export DPDK_TARGET=x86_64-native-linuxapp-gcc
export RTE_SDK=/root/OVSGW/dpdk-stable-19.11.2
export RTE_TARGET=x86_64-native-linuxapp-gcc
export DPDK_BUILD=$DPDK_DIR/x86_64-native-linuxapp-gcc
export LD_LIBRARY_PATH=$DPDK_DIR/x86_64-native-linuxapp-gcc/lib

. common

cd dpdk-stable-19.11.2/

make install T=$DPDK_TARGET DESTDIR=install

cd openvswitch-2.14.1

./configure --with-dpdk=$DPDK_BUILD

make

make install

-----------make install输出-----------------

[root@localhost openvswitch-2.14.1]# make install
make  install-recursive
make[1]: Entering directory `/root/OVSGW/openvswitch-2.14.1'
Making install in datapath
make[2]: Entering directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[3]: Entering directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[4]: Entering directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[4]: Nothing to be done for `install-exec-am'.
make[4]: Nothing to be done for `install-data-am'.
make[4]: Leaving directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[3]: Leaving directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[2]: Leaving directory `/root/OVSGW/openvswitch-2.14.1/datapath'
make[2]: Entering directory `/root/OVSGW/openvswitch-2.14.1'
make[3]: Entering directory `/root/OVSGW/openvswitch-2.14.1'
 /usr/bin/mkdir -p '/usr/local/lib'
 /bin/sh ./libtool   --mode=install /usr/bin/install -c   lib/libopenvswitch.la lib/libsflow.la ofproto/libofproto.la ovsdb/libovsdb.la vtep/libvtep.la '/usr/local/lib'
libtool: install: /usr/bin/install -c lib/.libs/libopenvswitch.lai /usr/local/lib/libopenvswitch.la
libtool: install: /usr/bin/install -c lib/.libs/libsflow.lai /usr/local/lib/libsflow.la
libtool: install: /usr/bin/install -c ofproto/.libs/libofproto.lai /usr/local/lib/libofproto.la
libtool: install: /usr/bin/install -c ovsdb/.libs/libovsdb.lai /usr/local/lib/libovsdb.la
libtool: install: /usr/bin/install -c vtep/.libs/libvtep.lai /usr/local/lib/libvtep.la
libtool: install: /usr/bin/install -c lib/.libs/libopenvswitch.a /usr/local/lib/libopenvswitch.a
libtool: install: chmod 644 /usr/local/lib/libopenvswitch.a
libtool: install: ranlib /usr/local/lib/libopenvswitch.a
libtool: install: /usr/bin/install -c lib/.libs/libsflow.a /usr/local/lib/libsflow.a
libtool: install: chmod 644 /usr/local/lib/libsflow.a
libtool: install: ranlib /usr/local/lib/libsflow.a
libtool: install: /usr/bin/install -c ofproto/.libs/libofproto.a /usr/local/lib/libofproto.a
libtool: install: chmod 644 /usr/local/lib/libofproto.a
libtool: install: ranlib /usr/local/lib/libofproto.a
libtool: install: /usr/bin/install -c ovsdb/.libs/libovsdb.a /usr/local/lib/libovsdb.a
libtool: install: chmod 644 /usr/local/lib/libovsdb.a
libtool: install: ranlib /usr/local/lib/libovsdb.a
libtool: install: /usr/bin/install -c vtep/.libs/libvtep.a /usr/local/lib/libvtep.a
libtool: install: chmod 644 /usr/local/lib/libvtep.a
libtool: install: ranlib /usr/local/lib/libvtep.a
libtool: finish: PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/sbin" ldconfig -n /usr/local/lib
----------------------------------------------------------------------
Libraries have been installed in:
   /usr/local/lib

If you ever happen to want to link against installed libraries
in a given directory, LIBDIR, you must either use libtool, and
specify the full pathname of the library, or use the '-LLIBDIR'
flag during linking and do at least one of the following:
   - add LIBDIR to the 'LD_LIBRARY_PATH' environment variable
     during execution
   - add LIBDIR to the 'LD_RUN_PATH' environment variable
     during linking
   - use the '-Wl,-rpath -Wl,LIBDIR' linker flag
   - have your system administrator add LIBDIR to '/etc/ld.so.conf'

See any operating system documentation about shared libraries for
more information, such as the ld(1) and ld.so(8) manual pages.
----------------------------------------------------------------------
 /usr/bin/mkdir -p '/usr/local/bin'
  /bin/sh ./libtool   --mode=install /usr/bin/install -c utilities/ovs-appctl utilities/ovs-testcontroller utilities/ovs-dpctl utilities/ovs-ofctl utilities/ovs-vsctl ovsdb/ovsdb-tool ovsdb/ovsdb-client vtep/vtep-ctl '/usr/local/bin'
libtool: install: /usr/bin/install -c utilities/ovs-appctl /usr/local/bin/ovs-appctl
libtool: install: /usr/bin/install -c utilities/ovs-testcontroller /usr/local/bin/ovs-testcontroller
libtool: install: /usr/bin/install -c utilities/ovs-dpctl /usr/local/bin/ovs-dpctl
libtool: install: /usr/bin/install -c utilities/ovs-ofctl /usr/local/bin/ovs-ofctl
libtool: install: /usr/bin/install -c utilities/ovs-vsctl /usr/local/bin/ovs-vsctl
libtool: install: /usr/bin/install -c ovsdb/ovsdb-tool /usr/local/bin/ovsdb-tool
libtool: install: /usr/bin/install -c ovsdb/ovsdb-client /usr/local/bin/ovsdb-client
libtool: install: /usr/bin/install -c vtep/vtep-ctl /usr/local/bin/vtep-ctl
 /usr/bin/mkdir -p '/usr/local/bin'
 /usr/bin/install -c utilities/ovs-docker utilities/ovs-pki utilities/ovs-pcap utilities/ovs-tcpdump utilities/ovs-tcpundump utilities/ovs-dpctl-top utilities/ovs-l3ping utilities/ovs-parse-backtrace utilities/ovs-test utilities/ovs-vlan-test '/usr/local/bin'
 /usr/bin/mkdir -p '/usr/local/sbin'
  /bin/sh ./libtool   --mode=install /usr/bin/install -c vswitchd/ovs-vswitchd ovsdb/ovsdb-server '/usr/local/sbin'
libtool: install: /usr/bin/install -c vswitchd/ovs-vswitchd /usr/local/sbin/ovs-vswitchd
libtool: install: /usr/bin/install -c ovsdb/ovsdb-server /usr/local/sbin/ovsdb-server
 /usr/bin/mkdir -p '/usr/local/sbin'
 /usr/bin/install -c utilities/bugtool/ovs-bugtool '/usr/local/sbin'
 /usr/bin/mkdir -p '/usr/local/etc/bash_completion.d'
 /usr/bin/install -c utilities/ovs-appctl-bashcomp.bash utilities/ovs-vsctl-bashcomp.bash '/usr/local/etc/bash_completion.d'
/usr/bin/mkdir -p /usr/local/var/lib/openvswitch/pki
/usr/bin/mkdir -p /usr/local/etc/openvswitch
for plugin in utilities/bugtool/plugins/kernel-info/openvswitch.xml utilities/bugtool/plugins/network-status/openvswitch.xml utilities/bugtool/plugins/system-configuration.xml utilities/bugtool/plugins/system-logs/openvswitch.xml utilities/bugtool/plugins/system-configuration/openvswitch.xml; do \
  stem=`echo "$plugin" | sed 's,utilities/bugtool/plugins/,,'`; \
  dir=`expr "$stem" : '\(.*\)/[^/]*$'`; \
  /usr/bin/mkdir -p "/usr/local/share/openvswitch/bugtool-plugins/$dir"; \
  /usr/bin/install -c -m 644 "./$plugin" "/usr/local/share/openvswitch/bugtool-plugins/$stem"; \
done
/usr/bin/mkdir -p python/ovs
sed \
        -e '/^##/d' \
        -e 's,[@]pkgdatadir[@],/usr/local/share/openvswitch,g' \
        -e 's,[@]RUNDIR[@],/usr/local/var/run/openvswitch,g' \
        -e 's,[@]LOGDIR[@],/usr/local/var/log/openvswitch,g' \
        -e 's,[@]bindir[@],/usr/local/bin,g' \
        -e 's,[@]sysconfdir[@],/usr/local/etc,g' \
        -e 's,[@]DBDIR[@],/usr/local/etc/openvswitch,g' \
        < ./python/ovs/dirs.py.template \
        > python/ovs/dirs.py.tmp
/usr/bin/mkdir -p /usr/local/share/openvswitch/python/ovs
/usr/bin/install -c -m 644 python/ovs/dirs.py.tmp /usr/local/share/openvswitch/python/ovs/dirs.py
rm python/ovs/dirs.py.tmp
 /usr/bin/mkdir -p '/usr/local/share/man/man1'
 /usr/bin/install -c -m 644 utilities/ovs-pcap.1 ovsdb/ovsdb-tool.1 ovsdb/ovsdb-client.1 ovsdb/ovsdb-server.1 '/usr/local/share/man/man1'
 /usr/bin/mkdir -p '/usr/local/share/man/man5'
 /usr/bin/install -c -m 644 vswitchd/ovs-vswitchd.conf.db.5 ovsdb/ovsdb-server.5 vtep/vtep.5 '/usr/local/share/man/man5'
 /usr/bin/mkdir -p '/usr/local/share/man/man7'
 /usr/bin/install -c -m 644 lib/ovs-fields.7 lib/ovs-actions.7 '/usr/local/share/man/man7'
 /usr/bin/mkdir -p '/usr/local/share/man/man8'
 /usr/bin/install -c -m 644 utilities/ovs-testcontroller.8 utilities/ovs-dpctl.8 utilities/ovs-dpctl-top.8 utilities/ovs-kmod-ctl.8 utilities/ovs-ofctl.8 utilities/ovs-vsctl.8 utilities/bugtool/ovs-bugtool.8 vswitchd/ovs-vswitchd.8 vtep/vtep-ctl.8 '/usr/local/share/man/man8'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovs/unixctl'
 /usr/bin/install -c -m 644  python/ovs/unixctl/__init__.py python/ovs/unixctl/client.py python/ovs/unixctl/server.py '/usr/local/share/openvswitch/python/ovs/unixctl'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovs/compat'
 /usr/bin/install -c -m 644  python/ovs/compat/__init__.py '/usr/local/share/openvswitch/python/ovs/compat'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovs/db'
 /usr/bin/install -c -m 644  python/ovs/db/__init__.py python/ovs/db/custom_index.py python/ovs/db/data.py python/ovs/db/error.py python/ovs/db/idl.py python/ovs/db/parser.py python/ovs/db/schema.py python/ovs/db/types.py '/usr/local/share/openvswitch/python/ovs/db'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovs'
 /usr/bin/install -c -m 644  python/ovs/__init__.py python/ovs/daemon.py python/ovs/fcntl_win.py python/ovs/fatal_signal.py python/ovs/json.py python/ovs/jsonrpc.py python/ovs/ovsuuid.py python/ovs/poller.py python/ovs/process.py python/ovs/reconnect.py python/ovs/socket_util.py python/ovs/stream.py python/ovs/timeval.py python/ovs/util.py python/ovs/version.py python/ovs/vlog.py python/ovs/winutils.py '/usr/local/share/openvswitch/python/ovs'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovs/compat/sortedcontainers'
 /usr/bin/install -c -m 644  python/ovs/compat/sortedcontainers/__init__.py python/ovs/compat/sortedcontainers/sortedlist.py python/ovs/compat/sortedcontainers/sorteddict.py python/ovs/compat/sortedcontainers/sortedset.py '/usr/local/share/openvswitch/python/ovs/compat/sortedcontainers'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/python/ovstest'
 /usr/bin/install -c -m 644  python/ovstest/__init__.py python/ovstest/args.py python/ovstest/rpcserver.py python/ovstest/tcp.py python/ovstest/tests.py python/ovstest/udp.py python/ovstest/util.py python/ovstest/vswitch.py '/usr/local/share/openvswitch/python/ovstest'
 /usr/bin/mkdir -p '/usr/local/include/openflow'
 /usr/bin/install -c -m 644 include/openflow/intel-ext.h include/openflow/netronome-ext.h include/openflow/nicira-ext.h include/openflow/openflow-1.0.h include/openflow/openflow-1.1.h include/openflow/openflow-1.2.h include/openflow/openflow-1.3.h include/openflow/openflow-1.4.h include/openflow/openflow-1.5.h include/openflow/openflow-common.h include/openflow/openflow.h '/usr/local/include/openflow'
 /usr/bin/mkdir -p '/usr/local/include/openvswitch'
 /usr/bin/install -c -m 644 include/openvswitch/compiler.h include/openvswitch/dynamic-string.h include/openvswitch/hmap.h include/openvswitch/flow.h include/openvswitch/geneve.h include/openvswitch/json.h include/openvswitch/list.h include/openvswitch/netdev.h include/openvswitch/match.h include/openvswitch/meta-flow.h include/openvswitch/namemap.h include/openvswitch/ofpbuf.h include/openvswitch/ofp-actions.h include/openvswitch/ofp-bundle.h include/openvswitch/ofp-connection.h include/openvswitch/ofp-ed-props.h include/openvswitch/ofp-errors.h include/openvswitch/ofp-flow.h include/openvswitch/ofp-group.h include/openvswitch/ofp-ipfix.h include/openvswitch/ofp-match.h include/openvswitch/ofp-meter.h include/openvswitch/ofp-monitor.h include/openvswitch/ofp-msgs.h include/openvswitch/ofp-packet.h include/openvswitch/ofp-parse.h include/openvswitch/ofp-port.h include/openvswitch/ofp-print.h include/openvswitch/ofp-prop.h include/openvswitch/ofp-protocol.h include/openvswitch/ofp-queue.h include/openvswitch/ofp-switch.h include/openvswitch/ofp-table.h include/openvswitch/ofp-util.h include/openvswitch/packets.h include/openvswitch/poll-loop.h include/openvswitch/rconn.h include/openvswitch/shash.h include/openvswitch/thread.h include/openvswitch/token-bucket.h '/usr/local/include/openvswitch'
 /usr/bin/install -c -m 644 include/openvswitch/tun-metadata.h include/openvswitch/type-props.h include/openvswitch/types.h include/openvswitch/util.h include/openvswitch/uuid.h include/openvswitch/version.h include/openvswitch/vconn.h include/openvswitch/vlog.h include/openvswitch/nsh.h '/usr/local/include/openvswitch'
 /usr/bin/mkdir -p '/usr/local/lib/pkgconfig'
 /usr/bin/install -c -m 644 lib/libopenvswitch.pc lib/libsflow.pc ofproto/libofproto.pc ovsdb/libovsdb.pc '/usr/local/lib/pkgconfig'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch'
 /usr/bin/install -c -m 644 vswitchd/vswitch.ovsschema vtep/vtep.ovsschema '/usr/local/share/openvswitch'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/scripts'
 /usr/bin/install -c -m 644 utilities/ovs-lib '/usr/local/share/openvswitch/scripts'
 /usr/bin/mkdir -p '/usr/local/share/openvswitch/scripts'
 /usr/bin/install -c utilities/ovs-check-dead-ifs utilities/ovs-ctl utilities/ovs-kmod-ctl utilities/ovs-save utilities/bugtool/ovs-bugtool-fdb-show utilities/bugtool/ovs-bugtool-tc-class-show utilities/bugtool/ovs-bugtool-daemons-ver utilities/bugtool/ovs-bugtool-ovs-ofctl-loop-over-bridges utilities/bugtool/ovs-bugtool-ovs-appctl-dpif utilities/bugtool/ovs-bugtool-ovs-bridge-datapath-type utilities/bugtool/ovs-bugtool-ovs-vswitchd-threads-affinity utilities/bugtool/ovs-bugtool-qos-configs utilities/bugtool/ovs-bugtool-get-dpdk-nic-numa utilities/bugtool/ovs-bugtool-get-port-stats ipsec/ovs-monitor-ipsec vtep/ovs-vtep '/usr/local/share/openvswitch/scripts'
make[3]: Leaving directory `/root/OVSGW/openvswitch-2.14.1'
make[2]: Leaving directory `/root/OVSGW/openvswitch-2.14.1'
make[1]: Leaving directory `/root/OVSGW/openvswitch-2.14.1'
------------------------------------


//////// 1. 定义openflow action

所有action定义在lib/ofp-actions.c

在enum ofp_raw_action_type {中添加

    /* OF1.0+(28): struct ofp_action_config_gw. */
    OFPAT_RAW_CONFIG_GW,

    /* OF1.0+(29): struct ofp_action_handle_gw. */
    OFPAT_RAW_HANDLE_GW,

注：注释非常重要，说明了协议版本，序号，构造openflow消息所需参数
有些函数头是根据协议版本、代码和操作所需的参数类型自动生成的。 后面的序号是独一无二的，不能在同一协议版本中出现两个一样的序号

    /* OF1.0+(29): uint32_t. */
　　OFPAT_RAW_PROBDROP,

配置了上述后，编译过程会自动生成函数
put_OFPAT_action构造openflow消息
put_OFPAT_PROBDROP: 根据 uint32_t构造出openflow消息

定义openflow action
+ /* OF1.0(28): ovs_be32. */
+ OFPAT_RAW10_HANDLE_EXAMPLE,
+ /* OF1.1(28): ovs_be32. */
+ OFPAT_RAW11_HANDLE_EXAMPLE,
+ /* OF1.2-1.4(28): ovs_be32. */
+ OFPAT_RAW12_HANDLE_EXAMPLE,

构造出
put_OFPATx_HANDLE_EXAMPLE: 根据ovs_be32构造出openflow消息
put_OFPAT10_HANDLE_EXAMPLE(out);
put_OFPAT11_HANDLE_EXAMPLE(out);
put_OFPAT12_HANDLE_EXAMPLE(out);

    /* NX1.0+(10): struct nx_action_multipath. VLMFF */
    NXAST_RAW_MULTIPATH,

    /* NX1.0+(34): struct nx_action_conjunction. */
    NXAST_RAW_CONJUNCTION,

    /* NX1.0+(16): struct nx_action_learn, ... VLMFF */
    NXAST_RAW_LEARN,

所以上述我们的两个定义也会生成两个函数
put_OFPAT_CONFIG_GW 根据ofp_action_config_gw构造出openflow消息
put_OFPAT_HANDLE_GW 根据ofp_action_handle_gw构造出openflow消息

接下来定义struct ofp_action_config_gw和struct ofp_action_handle_gw

这里的参数类型有以下几种，可以给我们参考
uint16_t —————— 普通16位
uint8_t —————— 普通8位
uint32_t
uint64_t
ovs_be16 —————— big endian 16位
ovs_be32 —————— big endian 32位
struct ofp_action_dl_addr { —————— MAC地址
    ovs_be16 type;                  /* Type. */
    ovs_be16 len;                   /* Length is 16. */
    struct eth_addr dl_addr;        /* Ethernet address. */
    uint8_t pad[6];
};
OFP_ASSERT(sizeof(struct ofp_action_dl_addr) == 16);
struct nx_action_cnt_ids {
    ovs_be16 type;              /* OFPAT_VENDOR. */
    ovs_be16 len;               /* Length including slaves. */
    ovs_be32 vendor;            /* NX_VENDOR_ID. */
    ovs_be16 subtype;           /* NXAST_DEC_TTL_CNT_IDS. */

    ovs_be16 n_controllers;     /* Number of controllers. */
    uint8_t zeros[4];           /* Must be zero. */

    /* Followed by 1 or more controller ids:
     *
     * uint16_t cnt_ids[];      -- Controller ids.
     * uint8_t pad[];           -- Must be 0 to 8-byte align cnt_ids[].
     */
};
OFP_ASSERT(sizeof(struct nx_action_cnt_ids) == 16);
struct ofp15_action_copy_field {
    ovs_be16 type;              /* OFPAT_COPY_FIELD. */
    ovs_be16 len;               /* Length is padded to 64 bits. */
    ovs_be16 n_bits;            /* Number of bits to copy. */
    ovs_be16 src_offset;        /* Starting bit offset in source. */
    ovs_be16 dst_offset;        /* Starting bit offset in destination. */
    uint8_t pad[2];
    /* Followed by:
     * - OXM header for source field.
     * - OXM header for destination field.
     * - Padding with 0-bytes to a multiple of 8 bytes.
     * The "pad2" member is the beginning of the above. */
    uint8_t pad2[4];
};
OFP_ASSERT(sizeof(struct ofp15_action_copy_field) == 16);
struct nx_action_reg_load {
    ovs_be16 type;                  /* OFPAT_VENDOR. */
    ovs_be16 len;                   /* Length is 24. */
    ovs_be32 vendor;                /* NX_VENDOR_ID. */
    ovs_be16 subtype;               /* NXAST_REG_LOAD. */
    ovs_be16 ofs_nbits;             /* (ofs << 6) | (n_bits - 1). */
    ovs_be32 dst;                   /* Destination register. */
    ovs_be64 value;                 /* Immediate value. */
};
OFP_ASSERT(sizeof(struct nx_action_reg_load) == 24);
struct onf_action_copy_field {
    ovs_be16 type;              /* OFPAT_EXPERIMENTER. */
    ovs_be16 len;               /* Length is padded to 64 bits. */
    ovs_be32 experimenter;      /* ONF_VENDOR_ID. */
    ovs_be16 exp_type;          /* 3200. */
    uint8_t pad[2];             /* Not used. */
    ovs_be16 n_bits;            /* Number of bits to copy. */
    ovs_be16 src_offset;        /* Starting bit offset in source. */
    ovs_be16 dst_offset;        /* Starting bit offset in destination. */
    uint8_t pad2[2];            /* Not used. */
    /* Followed by:
     * - OXM header for source field.
     * - OXM header for destination field.
     * - Padding with 0-bytes (either 0 or 4 of them) to a multiple of 8 bytes.
     * The "pad3" member is the beginning of the above. */
    uint8_t pad3[4];            /* Not used. */
};
OFP_ASSERT(sizeof(struct onf_action_copy_field) == 24);
struct nx_action_conntrack {
    ovs_be16 type;              /* OFPAT_VENDOR. */
    ovs_be16 len;               /* At least 24. */
    ovs_be32 vendor;            /* NX_VENDOR_ID. */
    ovs_be16 subtype;           /* NXAST_CT. */
    ovs_be16 flags;             /* Zero or more NX_CT_F_* flags.
                                 * Unspecified flag bits must be zero. */
    ovs_be32 zone_src;          /* Connection tracking context. */
    union {
        ovs_be16 zone_ofs_nbits;/* Range to use from source field. */
        ovs_be16 zone_imm;      /* Immediate value for zone. */
    };
    uint8_t recirc_table;       /* Recirculate to a specific table, or
                                   NX_CT_RECIRC_NONE for no recirculation. */
    uint8_t pad[3];             /* Zeroes */
    ovs_be16 alg;               /* Well-known port number for the protocol.
                                 * 0 indicates no ALG is required. */
    /* Followed by a sequence of zero or more OpenFlow actions. The length of
     * these is included in 'len'. */
};
OFP_ASSERT(sizeof(struct nx_action_conntrack) == 24);
struct nx_action_learn {
    ovs_be16 type;              /* OFPAT_VENDOR. */
    ovs_be16 len;               /* At least 24. */
    ovs_be32 vendor;            /* NX_VENDOR_ID. */
    ovs_be16 subtype;           /* NXAST_LEARN. */
    ovs_be16 idle_timeout;      /* Idle time before discarding (seconds). */
    ovs_be16 hard_timeout;      /* Max time before discarding (seconds). */
    ovs_be16 priority;          /* Priority level of flow entry. */
    ovs_be64 cookie;            /* Cookie for new flow. */
    ovs_be16 flags;             /* NX_LEARN_F_*. */
    uint8_t table_id;           /* Table to insert flow entry. */
    uint8_t pad;                /* Must be zero. */
    ovs_be16 fin_idle_timeout;  /* Idle timeout after FIN, if nonzero. */
    ovs_be16 fin_hard_timeout;  /* Hard timeout after FIN, if nonzero. */
    /* Followed by a sequence of flow_mod_spec elements, as described above,
     * until the end of the action is reached. */
};
OFP_ASSERT(sizeof(struct nx_action_learn) == 32);
struct nx_action_learn2 {
    struct nx_action_learn up;  /* The wire format includes nx_action_learn. */
    ovs_be32 limit;             /* Maximum number of learned flows.
                                 * 0 indicates unlimited. */

    /* Where to store the result. */
    ovs_be16 result_dst_ofs;    /* Starting bit offset in destination. */

    ovs_be16 pad2;              /* Must be zero. */
    /* Followed by:
     * - OXM/NXM header for destination field (4 or 8 bytes),
     *   if NX_LEARN_F_WRITE_RESULT is set in 'flags'
     * - a sequence of flow_mod_spec elements, as described above,
     *   until the end of the action is reached. */
};
OFP_ASSERT(sizeof(struct nx_action_learn2) == 40);

struct nx_action_multipath {
    ovs_be16 type;              /* OFPAT_VENDOR. */
    ovs_be16 len;               /* Length is 32. */
    ovs_be32 vendor;            /* NX_VENDOR_ID. */
    ovs_be16 subtype;           /* NXAST_MULTIPATH. */

    /* What fields to hash and how. */
    ovs_be16 fields;            /* One of NX_HASH_FIELDS_*. */
    ovs_be16 basis;             /* Universal hash parameter. */
    ovs_be16 pad0;

    /* Multipath link choice algorithm to apply to hash value. */
    ovs_be16 algorithm;         /* One of NX_MP_ALG_*. */
    ovs_be16 max_link;          /* Number of output links, minus 1. */
    ovs_be32 arg;               /* Algorithm-specific argument. */
    ovs_be16 pad1;

    /* Where to store the result. */
    ovs_be16 ofs_nbits;         /* (ofs << 6) | (n_bits - 1). */
    ovs_be32 dst;               /* Destination. */
};
OFP_ASSERT(sizeof(struct nx_action_multipath) == 32);

struct nx_action_conjunction {
    ovs_be16 type;                  /* OFPAT_VENDOR. */
    ovs_be16 len;                   /* At least 16. */
    ovs_be32 vendor;                /* NX_VENDOR_ID. */
    ovs_be16 subtype;               /* See enum ofp_raw_action_type. */
    uint8_t clause;
    uint8_t n_clauses;
    ovs_be32 id;
};
OFP_ASSERT(sizeof(struct nx_action_conjunction) == 16);

我们添加两个struct的定义，并且设置cache对齐

struct ofp_action_config_gw {
    ovs_be16 type;
    ovs_be16 len;
    uint32_t param1;
    ovs_be32 param2;
    struct eth_addr param3;
    uint32_t param4;
    ovs_be32 param5;
    struct eth_addr param6;
    uint32_t param7;
    ovs_be32 param8;
    struct eth_addr param9;
    uint8_t pad[2];
};
OFP_ASSERT(sizeof(struct ofp_action_config_gw) == 48);

struct ofp_action_handle_gw {
    ovs_be16 type;
    ovs_be16 len;
    uint32_t pipeline1;
    uint32_t pipeline2;
    uint32_t pipeline3;
    uint32_t pipeline4;
    uint32_t pipeline5;
};
OFP_ASSERT(sizeof(struct ofp_action_handle_gw) == 24);

///////////////////2. 定义openvswitch action

所有action定义在include/openvswitch/ofp-actions.h中

OFPACT(HANDLE_EXAMPLE, ofpact_handle_example, ofpact, "handle_example") \

构造出

OFPACT_HANDLE_EXAMPLE

ofpact_put_HANDLE_EXAMPLE: 将ofpbuf转化为struct ofpact_handle_example: openflow消息转化openvswitch action

ofpact_get_HANDLE_EXAMPLE: 从ofpact获取为struct ofpact_handle_example: 获取openvswitch action

struct ofpact_handle_example {
struct ofpact ofpact;
uint32_t data;
};

#define OFPACTS                                                         \
    /* Output. */                                                       \
    OFPACT(OUTPUT,          ofpact_output,      ofpact, "output")       \
    OFPACT(GROUP,           ofpact_group,       ofpact, "group")        \
    OFPACT(CONTROLLER,      ofpact_controller,  ofpact, "controller")   \
    OFPACT(ENQUEUE,         ofpact_enqueue,     ofpact, "enqueue")      \
    OFPACT(OUTPUT_REG,      ofpact_output_reg,  ofpact, "output_reg")   \
    OFPACT(BUNDLE,          ofpact_bundle,      slaves, "bundle")       \
                                                                        \
    /* Header changes. */                                               \
    OFPACT(SET_FIELD,       ofpact_set_field,   ofpact, "set_field")    \
    OFPACT(HANDLE_GTP,      ofpact_null,        ofpact, "handle_gtp")    \
    OFPACT(HANDLE_PGW_SGI,  ofpact_null,        ofpact, "handle_pgw_sgi")    \
    OFPACT(OPERATE_GTP,     ofpact_operate_gtp, ofpact, "operate_gtp")    \
    OFPACT(GTP_TEID,        ofpact_gtp_teid,    ofpact, "gtp_teid")    \
    OFPACT(GTP_PGW_IP,      ofpact_gtp_pgw_ip,  ofpact, "gtp_pgw_ip")    \
    OFPACT(OVS_ID,          ofpact_ovs_id,      ofpact, "ovs_id")    \
    OFPACT(OVS_TOTAL,       ofpact_ovs_total,   ofpact, "ovs_total")    \
    OFPACT(GTP_PGW_PORT,    ofpact_gtp_pgw_port,ofpact, "gtp_pgw_port")    \
    OFPACT(OVS_PHY_PORT,    ofpact_ovs_phy_port,ofpact, "ovs_phy_port")    \
    OFPACT(PGW_SGI_PORT,    ofpact_pgw_sgi_port,ofpact, "pgw_sgi_port")    \
    OFPACT(PGW_FASTPATH,    ofpact_pgw_fastpath,ofpact, "pgw_fastpath")    \
    OFPACT(GTP_PGW_ETH,     ofpact_mac,         ofpact, "gtp_pgw_eth")   \
    OFPACT(PGW_SGI_ETH,     ofpact_mac,         ofpact, "pgw_sgi_eth")   \
    OFPACT(SET_VLAN_VID,    ofpact_vlan_vid,    ofpact, "set_vlan_vid") \
    OFPACT(SET_VLAN_PCP,    ofpact_vlan_pcp,    ofpact, "set_vlan_pcp") \
    OFPACT(STRIP_VLAN,      ofpact_null,        ofpact, "strip_vlan")   \
    OFPACT(PUSH_VLAN,       ofpact_null,        ofpact, "push_vlan")    \
    OFPACT(SET_ETH_SRC,     ofpact_mac,         ofpact, "mod_dl_src")   \
    OFPACT(SET_ETH_DST,     ofpact_mac,         ofpact, "mod_dl_dst")   \
    OFPACT(SET_IPV4_SRC,    ofpact_ipv4,        ofpact, "mod_nw_src")   \
    OFPACT(SET_IPV4_DST,    ofpact_ipv4,        ofpact, "mod_nw_dst")   \
    OFPACT(SET_IP_DSCP,     ofpact_dscp,        ofpact, "mod_nw_tos")   \
    OFPACT(SET_IP_ECN,      ofpact_ecn,         ofpact, "mod_nw_ecn")   \
    OFPACT(SET_IP_TTL,      ofpact_ip_ttl,      ofpact, "mod_nw_ttl")   \
    OFPACT(SET_L4_SRC_PORT, ofpact_l4_port,     ofpact, "mod_tp_src")   \
    OFPACT(SET_L4_DST_PORT, ofpact_l4_port,     ofpact, "mod_tp_dst")   \
    OFPACT(REG_MOVE,        ofpact_reg_move,    ofpact, "move")         \
    OFPACT(STACK_PUSH,      ofpact_stack,       ofpact, "push")         \
    OFPACT(STACK_POP,       ofpact_stack,       ofpact, "pop")          \
    OFPACT(DEC_TTL,         ofpact_cnt_ids,     cnt_ids, "dec_ttl")     \
    OFPACT(SET_MPLS_LABEL,  ofpact_mpls_label,  ofpact, "set_mpls_label") \
    OFPACT(SET_MPLS_TC,     ofpact_mpls_tc,     ofpact, "set_mpls_tc")  \
    OFPACT(SET_MPLS_TTL,    ofpact_mpls_ttl,    ofpact, "set_mpls_ttl") \
    OFPACT(DEC_MPLS_TTL,    ofpact_null,        ofpact, "dec_mpls_ttl") \
    OFPACT(PUSH_MPLS,       ofpact_push_mpls,   ofpact, "push_mpls")    \
    OFPACT(POP_MPLS,        ofpact_pop_mpls,    ofpact, "pop_mpls")     \

    OFPACT(CONJUNCTION,     ofpact_conjunction, ofpact, "conjunction")  \
    OFPACT(MULTIPATH,       ofpact_multipath,   ofpact, "multipath")    \

ofpact_null表示这个action没有参数
ofpact_gtp_pgw_ip表示这个action是有参数的

/* OFPACT_GTP_PGW_IP.
 * Used for OFPAT10_GTP_PGW_IP, OFPAT11_GTP_PGW_IP, OFPAT12_GTP_PGW_IP */
struct ofpact_gtp_pgw_ip {
    struct ofpact ofpact;
    ovs_be32 gtp_pgw_ip;
};

/usr/local/bin/ovs-ofctl add-flow sdmn_br "ip,nw_src=192.168.200.104 actions=operate_gtp:1,gtp_pgw_ip:${DOCKER_IP},gtp_pgw_port:${DOCKER_ETH1_PORT},gtp_pgw_eth:${DOCKER_ETH1_MAC},pgw_sgi_port:${DOCKER_ETH2_PORT},pgw_sgi_eth:${DOCKER_ETH2_MAC}"

/* OFPACT_CONJUNCTION.
 *
 * Used for NXAST_CONJUNCTION. */
struct ofpact_conjunction {
    struct ofpact ofpact;
    uint8_t clause;
    uint8_t n_clauses;
    uint32_t id;
};

/* OFPACT_MULTIPATH.
 *
 * Used for NXAST_MULTIPATH. */
struct ofpact_multipath {
    struct ofpact ofpact;

    /* What fields to hash and how. */
    enum nx_hash_fields fields;
    uint16_t basis;             /* Universal hash parameter. */

    /* Multipath link choice algorithm to apply to hash value. */
    enum nx_mp_algorithm algorithm;
    uint16_t max_link;          /* Number of output links, minus 1. */
    uint32_t arg;               /* Algorithm-specific argument. */

    /* Where to store the result. */
    struct mf_subfield dst;
};

struct ofpact_stack {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        struct mf_subfield subfield;
    );
};

对于我们来说，添加这两个

    OFPACT(CONFIG_GW,       ofpact_config_gw,   ofpact, "config_gw")  \
    OFPACT(HANDLE_GW,       ofpact_handle_gw,   ofpact, "handle_gw") \

这里相当于定义两个openvswitch action
OFPACT_CONFIG_GW
OFPACT_HANDLE_GW

还需要定义两个参数的结构

struct ofpact_config_gw {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint32_t param1;
        ovs_be32 param2;
        struct eth_addr param3;
        uint32_t param4;
        ovs_be32 param5;
        struct eth_addr param6;
        uint32_t param7;
        ovs_be32 param8;
        struct eth_addr param9;
    );
};

struct ofpact_handle_gw {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint32_t pipeline1;
        uint32_t pipeline2;
        uint32_t pipeline3;
        uint32_t pipeline4;
        uint32_t pipeline5;
    );
};

定义openvswitch action会生成一些列函数

/* For each OFPACT_<ENUM> with a corresponding struct <STRUCT>, this defines
 * the following commonly useful functions:
 *
 *   struct <STRUCT> *ofpact_put_<ENUM>(struct ofpbuf *ofpacts);
 *
 *     Appends a new 'ofpact', of length OFPACT_<ENUM>_SIZE, to 'ofpacts',
 *     initializes it with ofpact_init_<ENUM>(), and returns it.  Also sets
 *     'ofpacts->header' to the returned action.
 *
 *     After using this function to add a variable-length action, add the
 *     elements of the flexible array (e.g. with ofpbuf_put()), then use
 *     ofpact_finish() to pad the action to a multiple of OFPACT_ALIGNTO bytes
 *     and update its embedded length field.  (Keep in mind the need to refresh
 *     the structure from 'ofpacts->header' after adding data to 'ofpacts'.)
 *
 *   struct <STRUCT> *ofpact_get_<ENUM>(const struct ofpact *ofpact);
 *
 *     Returns 'ofpact' cast to "struct <STRUCT> *".  'ofpact->type' must be
 *     OFPACT_<ENUM>.
 *
 *   void ofpact_finish_<ENUM>(struct ofpbuf *ofpacts, struct <STRUCT> **ap);
 *
 *     Finishes composing variable-length action '*ap' (begun using
 *     ofpact_put_<NAME>() on 'ofpacts'), by padding the action to a multiple
 *     of OFPACT_ALIGNTO bytes and updating its embedded length field.
 *
 *     May reallocate 'ofpacts', and so as a convenience automatically updates
 *     '*ap' to point to the new location.  If the caller has other pointers
 *     within 'ap' or 'ofpacts', it needs to update them manually.
 *
 * as well as the following more rarely useful definitions:
 *
 *   void ofpact_init_<ENUM>(struct <STRUCT> *ofpact);
 *
 *     Initializes the parts of 'ofpact' that identify it as having type
 *     OFPACT_<ENUM> and length OFPACT_<ENUM>_SIZE and zeros the rest.
 */

ofpact_put_HANDLE_EXAMPLE: 将ofpbuf转化为struct ofpact_handle_example: openflow消息转化openvswitch action

ofpact_get_HANDLE_EXAMPLE: 从ofpact获取为struct ofpact_handle_example: 获取openvswitch action

ofpact_put_MULTIPATH是自动生成的，如何使用见如下代码

    struct ofpbuf *out;
    struct ofpact_multipath *mp;
    mp = ofpact_put_MULTIPATH(out);
    mp->fields = ntohs(nam->fields);
    mp->basis = ntohs(nam->basis);
    mp->algorithm = ntohs(nam->algorithm);
    mp->max_link = ntohs(nam->max_link);
    mp->arg = ntohl(nam->arg);
    mp->dst.ofs = nxm_decode_ofs(nam->ofs_nbits);
    mp->dst.n_bits = nxm_decode_n_bits(nam->ofs_nbits);

ofpact_put_CONJUNCTION是自动生成的，如何使用见如下代码

    struct ofpbuf *out;
    struct ofpact_conjunction *oc;
    oc = ofpact_put_CONJUNCTION(out);
    oc->id = id;
    oc->clause = clause;
    oc->n_clauses = n_clauses;

//////////////3. openflow action与openvswitch action转化


openflow action 与openvswitch action 有对应关系在ofpact_map中, 可以理解为多个版本openflow对应一个openvswitch action

 { OFPACT_HANDLE_EXAMPLE, 28 },
 { OFPACT_HANDLE_EXAMPLE, 28 },
 { OFPACT_HANDLE_EXAMPLE, 28 },

我们修改static const struct ofpact_map * get_ofpact_map(enum ofp_version version)

做了一个映射OFPACT_CONFIG_GW是openvswitch的action，28是openflow的action

static const struct ofpact_map *
get_ofpact_map(enum ofp_version version)
{
    /* OpenFlow 1.0 actions. */
    static const struct ofpact_map of10[] = {
        { OFPACT_OUTPUT, 0 },
        { OFPACT_SET_VLAN_VID, 1 },
        { OFPACT_SET_VLAN_PCP, 2 },
        { OFPACT_STRIP_VLAN, 3 },
        { OFPACT_SET_ETH_SRC, 4 },
        { OFPACT_SET_ETH_DST, 5 },
        { OFPACT_SET_IPV4_SRC, 6 },
        { OFPACT_SET_IPV4_DST, 7 },
        { OFPACT_SET_IP_DSCP, 8 },
        { OFPACT_SET_L4_SRC_PORT, 9 },
        { OFPACT_SET_L4_DST_PORT, 10 },
        { OFPACT_ENQUEUE, 11 },
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    /* OpenFlow 1.1 actions. */
    static const struct ofpact_map of11[] = {
        { OFPACT_OUTPUT, 0 },
        { OFPACT_SET_VLAN_VID, 1 },
        { OFPACT_SET_VLAN_PCP, 2 },
        { OFPACT_SET_ETH_SRC, 3 },
        { OFPACT_SET_ETH_DST, 4 },
        { OFPACT_SET_IPV4_SRC, 5 },
        { OFPACT_SET_IPV4_DST, 6 },
        { OFPACT_SET_IP_DSCP, 7 },
        { OFPACT_SET_IP_ECN, 8 },
        { OFPACT_SET_L4_SRC_PORT, 9 },
        { OFPACT_SET_L4_DST_PORT, 10 },
        /* OFPAT_COPY_TTL_OUT (11) not supported. */
        /* OFPAT_COPY_TTL_IN (12) not supported. */
        { OFPACT_SET_MPLS_LABEL, 13 },
        { OFPACT_SET_MPLS_TC, 14 },
        { OFPACT_SET_MPLS_TTL, 15 },
        { OFPACT_DEC_MPLS_TTL, 16 },
        { OFPACT_PUSH_VLAN, 17 },
        { OFPACT_STRIP_VLAN, 18 },
        { OFPACT_PUSH_MPLS, 19 },
        { OFPACT_POP_MPLS, 20 },
        { OFPACT_SET_QUEUE, 21 },
        { OFPACT_GROUP, 22 },
        { OFPACT_SET_IP_TTL, 23 },
        { OFPACT_DEC_TTL, 24 },
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    /* OpenFlow 1.2, 1.3, and 1.4 actions. */
    static const struct ofpact_map of12[] = {
        { OFPACT_OUTPUT, 0 },
        /* OFPAT_COPY_TTL_OUT (11) not supported. */
        /* OFPAT_COPY_TTL_IN (12) not supported. */
        { OFPACT_SET_MPLS_TTL, 15 },
        { OFPACT_DEC_MPLS_TTL, 16 },
        { OFPACT_PUSH_VLAN, 17 },
        { OFPACT_STRIP_VLAN, 18 },
        { OFPACT_PUSH_MPLS, 19 },
        { OFPACT_POP_MPLS, 20 },
        { OFPACT_SET_QUEUE, 21 },
        { OFPACT_GROUP, 22 },
        { OFPACT_SET_IP_TTL, 23 },
        { OFPACT_DEC_TTL, 24 },
        { OFPACT_SET_FIELD, 25 },
        /* OF1.3+ OFPAT_PUSH_PBB (26) not supported. */
        /* OF1.3+ OFPAT_POP_PBB (27) not supported. */
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    switch (version) {
    case OFP10_VERSION:
        return of10;

    case OFP11_VERSION:
        return of11;

    case OFP12_VERSION:
    case OFP13_VERSION:
    case OFP14_VERSION:
    case OFP15_VERSION:
    default:
        return of12;
    }
}





openflow action与openvswitch action转化
ofpact_decode---->decode_OFPAT_RAW_PROBDROP: 解openflow消息生成openvswitch action
ofpact_encode---->encode_PROBDROP: 从ofpact_type构造openflow消息
ofpact_parse---->parse_PROBDROP: 从字符串解析构造openvswitch action
ofpact_format---->format_PROBDROP: 将openvswitch action转化为string
ofpact_format---->check_PROBDROP:校验openvswitch action


我们参考一个结构稍微复杂的decode和encode方法

    openflow action的相关定义
    /* OF1.0(4), OF1.1(3), OF1.2+(3) is deprecated (use Set-Field): struct
     * ofp_action_dl_addr. */
    OFPAT_RAW_SET_DL_SRC,

    /* OF1.0(5), OF1.1(4), OF1.2+(4) is deprecated (use Set-Field): struct
     * ofp_action_dl_addr. */
    OFPAT_RAW_SET_DL_DST,

    struct ofp_action_dl_addr {
        ovs_be16 type;                  /* Type. */
        ovs_be16 len;                   /* Length is 16. */
        struct eth_addr dl_addr;        /* Ethernet address. */
        uint8_t pad[6];
    };
    OFP_ASSERT(sizeof(struct ofp_action_dl_addr) == 16);

    openvswitch action的相关定义
    OFPACT(SET_ETH_SRC,     ofpact_mac,         ofpact, "mod_dl_src")   \
    OFPACT(SET_ETH_DST,     ofpact_mac,         ofpact, "mod_dl_dst")   \

    struct ofpact_mac {
        OFPACT_PADDED_MEMBERS(
            struct ofpact ofpact;
            struct eth_addr mac;
        );
    };

static enum ofperr
decode_OFPAT_RAW_SET_DL_SRC(const struct ofp_action_dl_addr *a,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
/*
ofpact_put_SET_ETH_SRC(out)将struct ofpbuf转换为struct ofpact_mac，是openvswitch action
struct ofp_action_dl_addr是openflow action

将openflow action赋值给openvswitch action
*/
    ofpact_put_SET_ETH_SRC(out)->mac = a->dl_addr;
    return 0;
}

static enum ofperr
decode_OFPAT_RAW_SET_DL_DST(const struct ofp_action_dl_addr *a,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
    ofpact_put_SET_ETH_DST(out)->mac = a->dl_addr;
    return 0;
}

static void
encode_SET_ETH_addr(const struct ofpact_mac *mac, enum ofp_version ofp_version,
                    enum ofp_raw_action_type raw, enum mf_field_id field,
                    struct ofpbuf *out)
{
    if (ofp_version < OFP12_VERSION) {
        struct ofp_action_dl_addr *oada;

        oada = ofpact_put_raw(out, ofp_version, raw, 0);
        oada->dl_addr = mac->mac;
    } else {
        put_set_field(out, ofp_version, field, eth_addr_to_uint64(mac->mac));
    }
}

static void
encode_SET_ETH_SRC(const struct ofpact_mac *mac, enum ofp_version ofp_version,
                   struct ofpbuf *out)
{
    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_SRC, MFF_ETH_SRC,
                        out);

}

static void
encode_SET_ETH_DST(const struct ofpact_mac *mac,
                               enum ofp_version ofp_version,
                               struct ofpbuf *out)
{
    encode_SET_ETH_addr(mac, ofp_version, OFPAT_RAW_SET_DL_DST, MFF_ETH_DST,
                        out);

}

static char * OVS_WARN_UNUSED_RESULT
parse_SET_ETH_SRC(char *arg, const struct ofpact_parse_params *pp)
{
/*
ofpact_put_SET_ETH_SRC(out)将struct ofpbuf转换为struct ofpact_mac，是openvswitch action
从字符串解析构造openvswitch action
*/
    return str_to_mac(arg, &ofpact_put_SET_ETH_SRC(pp->ofpacts)->mac);
}

static char * OVS_WARN_UNUSED_RESULT
parse_SET_ETH_DST(char *arg, const struct ofpact_parse_params *pp)
{
    return str_to_mac(arg, &ofpact_put_SET_ETH_DST(pp->ofpacts)->mac);
}

static void
format_SET_ETH_SRC(const struct ofpact_mac *a,
                   const struct ofpact_format_params *fp)
{
/*
struct ofpact_mac是openvswitch action
将openvswitch action转化为string
*/
    ds_put_format(fp->s, "%smod_dl_src:%s"ETH_ADDR_FMT,
                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));
}

static void
format_SET_ETH_DST(const struct ofpact_mac *a,
                   const struct ofpact_format_params *fp)
{
    ds_put_format(fp->s, "%smod_dl_dst:%s"ETH_ADDR_FMT,
                  colors.param, colors.end, ETH_ADDR_ARGS(a->mac));
}

static enum ofperr
check_SET_ETH_SRC(const struct ofpact_mac *a OVS_UNUSED,
                  const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}

static enum ofperr
check_SET_ETH_DST(const struct ofpact_mac *a OVS_UNUSED,
                  const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}

/* Set gtp pgw eth actions. */
static enum ofperr
decode_OFPAT_RAW10_GTP_PGW_ETH(const struct ofp_action_dl_addr *a,
                              enum ofp_version ofp_version OVS_UNUSED,
                              struct ofpbuf *out)
{
    ofpact_put_GTP_PGW_ETH(out)->mac = a->dl_addr;
    return 0;
}

static enum ofperr
decode_OFPAT_RAW11_GTP_PGW_ETH(const struct ofp_action_dl_addr *a,
                              enum ofp_version ofp_version OVS_UNUSED,
                              struct ofpbuf *out)
{
    ofpact_put_GTP_PGW_ETH(out)->mac = a->dl_addr;
    return 0;
}

static enum ofperr
decode_OFPAT_RAW12_GTP_PGW_ETH(const struct ofp_action_dl_addr *a,
                              enum ofp_version ofp_version OVS_UNUSED,
                              struct ofpbuf *out)
{
    ofpact_put_GTP_PGW_ETH(out)->mac = a->dl_addr;
    return 0;
}

static void
encode_GTP_PGW_ETH(const struct ofpact_mac *mac,
                  enum ofp_version ofp_version, struct ofpbuf *out)
{
/*
put_OFPAT10_GTP_PGW_ETH(out)将struct ofpbuf转换为struct ofp_action_dl_addr，是openflow action
struct ofpact_mac是openvswitch action

将openvswitch action赋值给openflow action
*/
    if (ofp_version == OFP10_VERSION) {
        put_OFPAT10_GTP_PGW_ETH(out)->dl_addr = mac->mac;
    } else if (ofp_version == OFP11_VERSION) {
        put_OFPAT11_GTP_PGW_ETH(out)->dl_addr = mac->mac;
    } else {
        put_OFPAT12_GTP_PGW_ETH(out)->dl_addr = mac->mac;
    }
}

static char * OVS_WARN_UNUSED_RESULT
parse_GTP_PGW_ETH(char *arg, struct ofpbuf *ofpacts,
                  enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    struct eth_addr gtp_pgw_eth;
    char *error;

    error = str_to_mac(arg, &gtp_pgw_eth);
    if (error) {
        return error;
    }

    ofpact_put_GTP_PGW_ETH(ofpacts)->mac = gtp_pgw_eth;
    return NULL;
}

static void
format_GTP_PGW_ETH(const struct ofpact_mac *a, struct ds *s)
{
    ds_put_format(s, "gtp_pgw_eth:"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->mac));
}

因为这里我们涉及key value的action，所以我们还需要参考learn的函数

actions=learn(dl_type=0x800, nw_proto=17, udp_dst=udp_src)
idle_timeout=seconds
hard_timeout=seconds
priority=value
cookie=value


static enum ofperr
decode_NXAST_RAW_LEARN(const struct nx_action_learn *nal,
                       enum ofp_version ofp_version OVS_UNUSED,
                       const struct vl_mff_map *vl_mff_map,
                       uint64_t *tlv_bitmap, struct ofpbuf *ofpacts)
{
    struct ofpact_learn *learn;
    enum ofperr error;

    learn = ofpact_put_LEARN(ofpacts);

    error = decode_LEARN_common(nal, NXAST_RAW_LEARN, learn);
    if (error) {
        return error;
    }

    if (learn->flags & ~(NX_LEARN_F_SEND_FLOW_REM |
                         NX_LEARN_F_DELETE_LEARNED)) {
        return OFPERR_OFPBAC_BAD_ARGUMENT;
    }

    return decode_LEARN_specs(nal + 1, (char *) nal + ntohs(nal->len),
                              vl_mff_map, tlv_bitmap, ofpacts);
}

static void
encode_LEARN(const struct ofpact_learn *learn,
             enum ofp_version ofp_version OVS_UNUSED, struct ofpbuf *out)
{
    const struct ofpact_learn_spec *spec;
    struct nx_action_learn *nal;
    size_t start_ofs;

    start_ofs = out->size;

    if (learn->ofpact.raw == NXAST_RAW_LEARN2
        || learn->limit != 0
        || learn->flags & NX_LEARN_F_WRITE_RESULT) {
        struct nx_action_learn2 *nal2;

        nal2 = put_NXAST_LEARN2(out);
        nal2->limit = htonl(learn->limit);
        nal2->result_dst_ofs = htons(learn->result_dst.ofs);
        nal = &nal2->up;
    } else {
        nal = put_NXAST_LEARN(out);
    }
    nal->idle_timeout = htons(learn->idle_timeout);
    nal->hard_timeout = htons(learn->hard_timeout);
    nal->fin_idle_timeout = htons(learn->fin_idle_timeout);
    nal->fin_hard_timeout = htons(learn->fin_hard_timeout);
    nal->priority = htons(learn->priority);
    nal->cookie = learn->cookie;
    nal->flags = htons(learn->flags);
    nal->table_id = learn->table_id;

    if (learn->flags & NX_LEARN_F_WRITE_RESULT) {
        nx_put_header(out, learn->result_dst.field->id, 0, false);
    }

    OFPACT_LEARN_SPEC_FOR_EACH (spec, learn) {
        put_u16(out, spec->n_bits | spec->dst_type | spec->src_type);

        if (spec->src_type == NX_LEARN_SRC_FIELD) {
            put_u32(out, nxm_header_from_mff(spec->src.field));
            put_u16(out, spec->src.ofs);
        } else {
            size_t n_dst_bytes = 2 * DIV_ROUND_UP(spec->n_bits, 16);
            uint8_t *bits = ofpbuf_put_zeros(out, n_dst_bytes);
            unsigned int n_bytes = DIV_ROUND_UP(spec->n_bits, 8);

            memcpy(bits + n_dst_bytes - n_bytes, ofpact_learn_spec_imm(spec),
                   n_bytes);
        }

        if (spec->dst_type == NX_LEARN_DST_MATCH ||
            spec->dst_type == NX_LEARN_DST_LOAD) {
            put_u32(out, nxm_header_from_mff(spec->dst.field));
            put_u16(out, spec->dst.ofs);
        }
    }

    pad_ofpat(out, start_ofs);
}

static char * OVS_WARN_UNUSED_RESULT
parse_LEARN(char *arg, const struct ofpact_parse_params *pp)
{
    return learn_parse(arg, pp->port_map, pp->table_map, pp->ofpacts);
}

static void
format_LEARN(const struct ofpact_learn *a,
             const struct ofpact_format_params *fp)
{
    learn_format(a, fp->port_map, fp->table_map, fp->s);
}

char * OVS_WARN_UNUSED_RESULT
learn_parse(char *arg, const struct ofputil_port_map *port_map,
            const struct ofputil_table_map *table_map,
            struct ofpbuf *ofpacts)
{
    char *orig = xstrdup(arg);
    char *error = learn_parse__(orig, arg, port_map, table_map, ofpacts);
    free(orig);
    return error;
}

static char * OVS_WARN_UNUSED_RESULT
learn_parse__(char *orig, char *arg, const struct ofputil_port_map *port_map,
              const struct ofputil_table_map *table_map,
              struct ofpbuf *ofpacts)
{
    struct ofpact_learn *learn;
    struct match match;
    char *name, *value;

    learn = ofpact_put_LEARN(ofpacts);
    learn->idle_timeout = OFP_FLOW_PERMANENT;
    learn->hard_timeout = OFP_FLOW_PERMANENT;
    learn->priority = OFP_DEFAULT_PRIORITY;
    learn->table_id = 1;

    match_init_catchall(&match);
    while (ofputil_parse_key_value(&arg, &name, &value)) {
        if (!strcmp(name, "table")) {
            if (!ofputil_table_from_string(value, table_map,
                                           &learn->table_id)) {
                return xasprintf("unknown table \"%s\"", value);
            } else if (learn->table_id == 255) {
                return xasprintf("%s: table id 255 not valid for `learn' "
                                 "action", orig);
            }
        } else if (!strcmp(name, "priority")) {
            learn->priority = atoi(value);
        } else if (!strcmp(name, "idle_timeout")) {
            learn->idle_timeout = atoi(value);
        } else if (!strcmp(name, "hard_timeout")) {
            learn->hard_timeout = atoi(value);
        } else if (!strcmp(name, "fin_idle_timeout")) {
            learn->fin_idle_timeout = atoi(value);
        } else if (!strcmp(name, "fin_hard_timeout")) {
            learn->fin_hard_timeout = atoi(value);
        } else if (!strcmp(name, "cookie")) {
            learn->cookie = htonll(strtoull(value, NULL, 0));
        } else if (!strcmp(name, "send_flow_rem")) {
            learn->flags |= NX_LEARN_F_SEND_FLOW_REM;
        } else if (!strcmp(name, "delete_learned")) {
            learn->flags |= NX_LEARN_F_DELETE_LEARNED;
        } else if (!strcmp(name, "limit")) {
            learn->limit = atoi(value);
        } else if (!strcmp(name, "result_dst")) {
            char *error;
            learn->flags |= NX_LEARN_F_WRITE_RESULT;
            error = mf_parse_subfield(&learn->result_dst, value);
            if (error) {
                return error;
            }
            if (!learn->result_dst.field->writable) {
                return xasprintf("%s is read-only", value);
            }
            if (learn->result_dst.n_bits != 1) {
                return xasprintf("result_dst in 'learn' action must be a "
                                 "single bit");
            }
        } else {
            struct ofpact_learn_spec *spec;
            char *error;

            spec = ofpbuf_put_zeros(ofpacts, sizeof *spec);
            error = learn_parse_spec(orig, name, value, port_map,
                                     spec, ofpacts, &match);
            if (error) {
                return error;
            }
            learn = ofpacts->header;
        }
    }

    if (ofpbuf_oversized(ofpacts)) {
        return xasprintf("input too big");
    }

    ofpact_finish_LEARN(ofpacts, &learn);

    return NULL;
}

static void
format_LEARN(const struct ofpact_learn *a,
             const struct ofpact_format_params *fp)
{
    learn_format(a, fp->port_map, fp->table_map, fp->s);
}

void
learn_format(const struct ofpact_learn *learn,
             const struct ofputil_port_map *port_map,
             const struct ofputil_table_map *table_map,
             struct ds *s)
{
    const struct ofpact_learn_spec *spec;
    struct match match;

    match_init_catchall(&match);

    ds_put_format(s, "%slearn(%s%stable=%s",
                  colors.learn, colors.end, colors.special, colors.end);
    ofputil_format_table(learn->table_id, table_map, s);
    if (learn->idle_timeout != OFP_FLOW_PERMANENT) {
        ds_put_format(s, ",%sidle_timeout=%s%"PRIu16,
                      colors.param, colors.end, learn->idle_timeout);
    }
    if (learn->hard_timeout != OFP_FLOW_PERMANENT) {
        ds_put_format(s, ",%shard_timeout=%s%"PRIu16,
                      colors.param, colors.end, learn->hard_timeout);
    }
    if (learn->fin_idle_timeout) {
        ds_put_format(s, ",%sfin_idle_timeout=%s%"PRIu16,
                      colors.param, colors.end, learn->fin_idle_timeout);
    }
    if (learn->fin_hard_timeout) {
        ds_put_format(s, "%s,fin_hard_timeout=%s%"PRIu16,
                      colors.param, colors.end, learn->fin_hard_timeout);
    }
    if (learn->priority != OFP_DEFAULT_PRIORITY) {
        ds_put_format(s, "%s,priority=%s%"PRIu16,
                      colors.special, colors.end, learn->priority);
    }
    if (learn->flags & NX_LEARN_F_SEND_FLOW_REM) {
        ds_put_format(s, ",%ssend_flow_rem%s", colors.value, colors.end);
    }
    if (learn->flags & NX_LEARN_F_DELETE_LEARNED) {
        ds_put_format(s, ",%sdelete_learned%s", colors.value, colors.end);
    }
    if (learn->cookie != 0) {
        ds_put_format(s, ",%scookie=%s%#"PRIx64,
                      colors.param, colors.end, ntohll(learn->cookie));
    }
    if (learn->limit != 0) {
        ds_put_format(s, ",%slimit=%s%"PRIu32,
                      colors.param, colors.end, learn->limit);
    }
    if (learn->flags & NX_LEARN_F_WRITE_RESULT) {
        ds_put_format(s, ",%sresult_dst=%s", colors.param, colors.end);
        mf_format_subfield(&learn->result_dst, s);
    }

    OFPACT_LEARN_SPEC_FOR_EACH (spec, learn) {
        unsigned int n_bytes = DIV_ROUND_UP(spec->n_bits, 8);
        ds_put_char(s, ',');

        switch (spec->src_type | spec->dst_type) {
        case NX_LEARN_SRC_IMMEDIATE | NX_LEARN_DST_MATCH: {
            if (spec->dst.ofs == 0
                && spec->dst.n_bits == spec->dst.field->n_bits) {
                union mf_value value;

                memset(&value, 0, sizeof value);
                memcpy(&value.b[spec->dst.field->n_bytes - n_bytes],
                       ofpact_learn_spec_imm(spec), n_bytes);
                ds_put_format(s, "%s%s=%s", colors.param,
                              spec->dst.field->name, colors.end);
                mf_format(spec->dst.field, &value, NULL, port_map, s);
            } else {
                ds_put_format(s, "%s", colors.param);
                mf_format_subfield(&spec->dst, s);
                ds_put_format(s, "=%s", colors.end);
                ds_put_hex(s, ofpact_learn_spec_imm(spec), n_bytes);
            }
            break;
        }
        case NX_LEARN_SRC_FIELD | NX_LEARN_DST_MATCH:
            ds_put_format(s, "%s", colors.param);
            mf_format_subfield(&spec->dst, s);
            ds_put_format(s, "%s", colors.end);
            if (spec->src.field != spec->dst.field ||
                spec->src.ofs != spec->dst.ofs) {
                ds_put_format(s, "%s=%s", colors.param, colors.end);
                mf_format_subfield(&spec->src, s);
            }
            break;

        case NX_LEARN_SRC_IMMEDIATE | NX_LEARN_DST_LOAD:
            ds_put_format(s, "%sload:%s", colors.special, colors.end);
            ds_put_hex(s, ofpact_learn_spec_imm(spec), n_bytes);
            ds_put_format(s, "%s->%s", colors.special, colors.end);
            mf_format_subfield(&spec->dst, s);
            break;

        case NX_LEARN_SRC_FIELD | NX_LEARN_DST_LOAD:
            ds_put_format(s, "%sload:%s", colors.special, colors.end);
            mf_format_subfield(&spec->src, s);
            ds_put_format(s, "%s->%s", colors.special, colors.end);
            mf_format_subfield(&spec->dst, s);
            break;

        case NX_LEARN_SRC_FIELD | NX_LEARN_DST_OUTPUT:
            ds_put_format(s, "%soutput:%s", colors.special, colors.end);
            mf_format_subfield(&spec->src, s);
            break;
        }
    }
    ds_put_format(s, "%s)%s", colors.learn, colors.end);
}

s表示短、l表示长；
ntohs =net to host short int 16位
htons=host to net short int 16位
ntohl =net to host long int 32位
htonl=host to net long int 32位

我们写 /* OF1.0+(28): struct ofp_action_config_gw. */ OFPAT_RAW_CONFIG_GW 对应的decode, encode, parse, format

static enum ofperr
decode_OFPAT_RAW_CONFIG_GW(const struct ofp_action_config_gw *a,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
    struct ofpact_config_gw *config_gw;

    config_gw = ofpact_put_CONFIG_GW(out);

    //may do ntohs htons ntohl htonl
    config_gw->param1 = a->param1;
    config_gw->param2 = a->param2;
    config_gw->param3 = a->param3;
    config_gw->param4 = a->param4;
    config_gw->param5 = a->param5;
    config_gw->param6 = a->param6;
    config_gw->param7 = a->param7;
    config_gw->param8 = a->param8;
    config_gw->param9 = a->param9;
}


static void
encode_CONFIG_GW(const struct ofpact_config_gw *config_gw,
                  enum ofp_version ofp_version, struct ofpbuf *out)
{

    struct ofp_action_config_gw *ofp_config_gw;

    ofp_config_gw = put_OFPAT_CONFIG_GW(out);

    //may do ntohs htons ntohl htonl
    ofp_config_gw->param1 = config_gw->param1;
    ofp_config_gw->param2 = config_gw->param2;
    ofp_config_gw->param3 = config_gw->param3;
    ofp_config_gw->param4 = config_gw->param4;
    ofp_config_gw->param5 = config_gw->param5;
    ofp_config_gw->param6 = config_gw->param6;
    ofp_config_gw->param7 = config_gw->param7;
    ofp_config_gw->param8 = config_gw->param8;
    ofp_config_gw->param9 = config_gw->param9;
}

static char * OVS_WARN_UNUSED_RESULT
parse_CONFIG_GW(const char *arg, const struct ofpact_parse_params *pp)
{
    struct ofpbuf *ofpacts;
    struct ofpact_config_gw *config_gw;
    char *name, *value;
    struct eth_addr ethaddr;
    char *error;

    ofpacts = pp->ofpacts;
    config_gw = ofpact_put_CONFIG_GW(ofpacts);

    while (ofputil_parse_key_value(&arg, &name, &value)) {
        if (!strcmp(name, "param1")) {
            config_gw->param1 = atoi(value);
        } else if (!strcmp(name, "param2")) {
            config_gw->param2 = atoi(value);
        } else if (!strcmp(name, "param3")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param3 = ethaddr;
        } else if (!strcmp(name, "param4")) {
            config_gw->param4 = atoi(value);
        } else if (!strcmp(name, "param5")) {
            config_gw->param5 = atoi(value);
        } else if (!strcmp(name, "param6")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param6 = ethaddr;
        } else if (!strcmp(name, "param7")) {
            config_gw->param7 = atoi(value);
        } else if (!strcmp(name, "param8")) {
            config_gw->param8 = atoi(value);
        } else if (!strcmp(name, "param9")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param9 = ethaddr;
        } 
    }

    return NULL;
}

static void
format_CONFIG_GW(const struct ofpact_config_gw *a, const struct ofpact_format_params *fp)
{
    struct ds *s;

    s = fp->s;

    ds_put_format(s, "config_gw(");
    if (a->param1 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param2 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param3 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }
    if (a->param4 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param5 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param6 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }
    if (a->param7 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param8 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param9 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }

    ds_put_format(s, ")");
}


////////////////////4. action实现，fast path，模式一，内核模式datapath

datapath\linux\compat\include\linux\openvswitch.h

enum ovs_action_attr {
    OVS_ACTION_ATTR_UNSPEC,
    OVS_ACTION_ATTR_OUTPUT,       /* u32 port number. */
    OVS_ACTION_ATTR_USERSPACE,    /* Nested OVS_USERSPACE_ATTR_*. */
    OVS_ACTION_ATTR_SET,          /* One nested OVS_KEY_ATTR_*. */
    OVS_ACTION_ATTR_PUSH_VLAN,    /* struct ovs_action_push_vlan. */
    OVS_ACTION_ATTR_POP_VLAN,     /* No argument. */
    OVS_ACTION_ATTR_SAMPLE,       /* Nested OVS_SAMPLE_ATTR_*. */
    OVS_ACTION_ATTR_RECIRC,       /* u32 recirc_id. */
    OVS_ACTION_ATTR_HASH,         /* struct ovs_action_hash. */
    OVS_ACTION_ATTR_PUSH_MPLS,    /* struct ovs_action_push_mpls. */
    OVS_ACTION_ATTR_POP_MPLS,     /* __be16 ethertype. */
    OVS_ACTION_ATTR_SET_MASKED,   /* One nested OVS_KEY_ATTR_* including
                       * data immediately followed by a mask.
                       * The data must be zero for the unmasked
                       * bits. */
    OVS_ACTION_ATTR_CT,           /* Nested OVS_CT_ATTR_* . */
    OVS_ACTION_ATTR_TRUNC,        /* u32 struct ovs_action_trunc. */
    OVS_ACTION_ATTR_PUSH_ETH,     /* struct ovs_action_push_eth. */
    OVS_ACTION_ATTR_POP_ETH,      /* No argument. */
    OVS_ACTION_ATTR_CT_CLEAR,     /* No argument. */
    OVS_ACTION_ATTR_PUSH_NSH,     /* Nested OVS_NSH_KEY_ATTR_*. */
    OVS_ACTION_ATTR_POP_NSH,      /* No argument. */
    OVS_ACTION_ATTR_METER,        /* u32 meter number. */
    OVS_ACTION_ATTR_CLONE,        /* Nested OVS_CLONE_ATTR_*.  */
    OVS_ACTION_ATTR_CHECK_PKT_LEN, /* Nested OVS_CHECK_PKT_LEN_ATTR_*. */

#ifndef __KERNEL__
    OVS_ACTION_ATTR_TUNNEL_PUSH,   /* struct ovs_action_push_tnl*/
    OVS_ACTION_ATTR_TUNNEL_POP,    /* u32 port number. */
    OVS_ACTION_ATTR_DROP,          /* u32 xlate_error. */
    OVS_ACTION_ATTR_LB_OUTPUT,     /* u32 bond-id. */
#endif
    __OVS_ACTION_ATTR_MAX,        /* Nothing past this will be accepted
                       * from userspace. */

#ifdef __KERNEL__
    OVS_ACTION_ATTR_SET_TO_MASKED, /* Kernel module internal masked
                    * set action converted from
                    * OVS_ACTION_ATTR_SET. */
#endif
};

/* Execute a list of actions against 'skb'. */
static int do_execute_actions(struct datapath *dp, struct sk_buff *skb,
                  struct sw_flow_key *key,
                  const struct nlattr *attr, int len)
{
    const struct nlattr *a;
    int rem;

    for (a = attr, rem = len; rem > 0;
         a = nla_next(a, &rem)) {
        int err = 0;

        switch (nla_type(a)) {
        case OVS_ACTION_ATTR_OUTPUT: {
            int port = nla_get_u32(a);
            struct sk_buff *clone;

            /* Every output action needs a separate clone
             * of 'skb', In case the output action is the
             * last action, cloning can be avoided.
             */
            if (nla_is_last(a, rem)) {
                do_output(dp, skb, port, key);
                /* 'skb' has been used for output.
                 */
                return 0;
            }

            clone = skb_clone(skb, GFP_ATOMIC);
            if (clone)
                do_output(dp, clone, port, key);
            OVS_CB(skb)->cutlen = 0;
            break;
        }

        case OVS_ACTION_ATTR_TRUNC: {
            struct ovs_action_trunc *trunc = nla_data(a);

            if (skb->len > trunc->max_len)
                OVS_CB(skb)->cutlen = skb->len - trunc->max_len;
            break;
        }

        case OVS_ACTION_ATTR_USERSPACE:
            output_userspace(dp, skb, key, a, attr,
                             len, OVS_CB(skb)->cutlen);
            OVS_CB(skb)->cutlen = 0;
            break;

        case OVS_ACTION_ATTR_HASH:
            execute_hash(skb, key, a);
            break;

        case OVS_ACTION_ATTR_PUSH_MPLS:
            err = push_mpls(skb, key, nla_data(a));
            break;

        case OVS_ACTION_ATTR_POP_MPLS:
            err = pop_mpls(skb, key, nla_get_be16(a));
            break;

        case OVS_ACTION_ATTR_PUSH_VLAN:
            err = push_vlan(skb, key, nla_data(a));
            break;

        case OVS_ACTION_ATTR_POP_VLAN:
            err = pop_vlan(skb, key);
            break;

        case OVS_ACTION_ATTR_RECIRC: {
            bool last = nla_is_last(a, rem);

            err = execute_recirc(dp, skb, key, a, last);
            if (last) {
                /* If this is the last action, the skb has
                 * been consumed or freed.
                 * Return immediately.
                 */
                return err;
            }
            break;
        }

        case OVS_ACTION_ATTR_SET:
            err = execute_set_action(skb, key, nla_data(a));
            break;

        case OVS_ACTION_ATTR_SET_MASKED:
        case OVS_ACTION_ATTR_SET_TO_MASKED:
            err = execute_masked_set_action(skb, key, nla_data(a));
            break;

        case OVS_ACTION_ATTR_SAMPLE: {
            bool last = nla_is_last(a, rem);

            err = sample(dp, skb, key, a, last);
            if (last)
                return err;

            break;
        }

        case OVS_ACTION_ATTR_CT:
            if (!is_flow_key_valid(key)) {
                err = ovs_flow_key_update(skb, key);
                if (err)
                    return err;
            }

            err = ovs_ct_execute(ovs_dp_get_net(dp), skb, key,
                         nla_data(a));

            /* Hide stolen IP fragments from user space. */
            if (err)
                return err == -EINPROGRESS ? 0 : err;
            break;

        case OVS_ACTION_ATTR_CT_CLEAR:
            err = ovs_ct_clear(skb, key);
            break;

        case OVS_ACTION_ATTR_PUSH_ETH:
            err = push_eth(skb, key, nla_data(a));
            break;

        case OVS_ACTION_ATTR_POP_ETH:
            err = pop_eth(skb, key);
            break;

        case OVS_ACTION_ATTR_PUSH_NSH: {
            u8 buffer[NSH_HDR_MAX_LEN];
            struct nshhdr *nh = (struct nshhdr *)buffer;

            err = nsh_hdr_from_nlattr(nla_data(a), nh,
                          NSH_HDR_MAX_LEN);
            if (unlikely(err))
                break;
            err = push_nsh(skb, key, nh);
            break;
        }

        case OVS_ACTION_ATTR_POP_NSH:
            err = pop_nsh(skb, key);
            break;

        case OVS_ACTION_ATTR_METER:
            if (ovs_meter_execute(dp, skb, key, nla_get_u32(a))) {
                consume_skb(skb);
                return 0;
            }
                       break;

        case OVS_ACTION_ATTR_CLONE: {
            bool last = nla_is_last(a, rem);

            err = clone(dp, skb, key, a, last);
            if (last)
                return err;
            break;
        }

        case OVS_ACTION_ATTR_CHECK_PKT_LEN: {
                        bool last = nla_is_last(a, rem);

                        err = execute_check_pkt_len(dp, skb, key, a, last);
                        if (last)
                                return err;

                        break;
                }
        }

        if (unlikely(err)) {
            kfree_skb(skb);
            return err;
        }
    }

/*
#ifndef HAVE_CONSUME_SKB
#define consume_skb kfree_skb
#endif
*/
    consume_skb(skb);
    return 0;
}

////////////////////5. action实现，fast path，模式二，DPDK模式



////////////////////6. fast path没有匹配上，upcall到慢路径，action实现，slow path

对于内核态的fast path，如何upcall到show path呢？

ovs_thread_create->udpif_upcall_handler->recv_upcalls->upcall_receive + process_upcall + handle_upcalls

process_upcall->upcall_xlate->xlate_actions->rule_dpif_lookup_from_table + do_xlate_actions

xlate_actions函数：openflow流表匹配完成后，调用do_xlate_actions函数把openflow action转化为精确流表的action；
Translating ofpact action- Kernel datapath  In ofproto-dpif-xlate.c do_xlate_actions nl_msg_put_u16
Eg.
 OpenFlows
table=0, priority=100 in_port=1,ip,actions=check_pkt_larger:1500->NXM_NX_REG0[0],resubmit(,1)
table=1, priority=200,in_port=1,ip,reg0=0x1/0x1 actions=output:3
table=1, priority=100,in_port=1,ip,actions=output:4
Translated to datapath action as:
 check_pkt_len(1500, gt(output:3), less_eq(output:4))

Translating ofpact action- DPDK datapath  in lib/odp-execute.c odp_execute_actions



handle_upcalls 将flow rule添加到内核中的fast path -> dpif_operate -> dpif_netlink_operate

handler线程只对传统ovs架构下,对内核upcall的消息进行处理。即慢速路径的处理就是handler线程的工作内容。ovs+dpdk下，handler线程也存在，但是一直处于堵塞状态，实际上什么也没干。ovs+dpdk下的慢速路径的处理直接由收包线程执行，由pmd线程做的。

对于DPDK的fast path，如果upcall到slow path呢？

fast_path_processing->dp_netdev_pmd_lookup_dpcls + dpcls_lookup(查找fast path)->如果miss，直接调用 handle_packet_upcall->dp_netdev_upcall + dp_netdev_execute_actions + dp_netdev_flow_add + emc_probabilistic_insert

dp_netdev_upcall->upcall_cb->upcall_receive + process_upcall
dp_netdev_execute_actions->odp_execute_actions->dp_execute_cb
dp_netdev_flow_add + emc_probabilistic_insert 将flow rule添加到DPDK中的fast path

upcall_receive 里面有
upcall->type = classify_upcall(type, userdata, &upcall->cookie);




lib/ofp-actions.c

/* Returns the ofpact following 'ofpact', except that if 'ofpact' contains
 * nested ofpacts it returns the first one. */
struct ofpact *
ofpact_next_flattened(const struct ofpact *ofpact)
{
    switch (ofpact->type) {
    case OFPACT_OUTPUT:
    case OFPACT_GROUP:
    case OFPACT_CONTROLLER:
    case OFPACT_ENQUEUE:
    case OFPACT_OUTPUT_REG:
    case OFPACT_OUTPUT_TRUNC:
    case OFPACT_BUNDLE:
    case OFPACT_SET_FIELD:
    case OFPACT_SET_VLAN_VID:
    case OFPACT_SET_VLAN_PCP:
    case OFPACT_STRIP_VLAN:
    case OFPACT_PUSH_VLAN:
    case OFPACT_SET_ETH_SRC:
    case OFPACT_SET_ETH_DST:
    case OFPACT_SET_IPV4_SRC:
    case OFPACT_SET_IPV4_DST:
    case OFPACT_SET_IP_DSCP:
    case OFPACT_SET_IP_ECN:
    case OFPACT_SET_IP_TTL:
    case OFPACT_SET_L4_SRC_PORT:
    case OFPACT_SET_L4_DST_PORT:
    case OFPACT_REG_MOVE:
    case OFPACT_STACK_PUSH:
    case OFPACT_STACK_POP:
    case OFPACT_DEC_TTL:
    case OFPACT_SET_MPLS_LABEL:
    case OFPACT_SET_MPLS_TC:
    case OFPACT_SET_MPLS_TTL:
    case OFPACT_DEC_MPLS_TTL:
    case OFPACT_PUSH_MPLS:
    case OFPACT_POP_MPLS:
    case OFPACT_SET_TUNNEL:
    case OFPACT_SET_QUEUE:
    case OFPACT_POP_QUEUE:
    case OFPACT_FIN_TIMEOUT:
    case OFPACT_RESUBMIT:
    case OFPACT_LEARN:
    case OFPACT_CONJUNCTION:
    case OFPACT_MULTIPATH:
    case OFPACT_NOTE:
    case OFPACT_EXIT:
    case OFPACT_SAMPLE:
    case OFPACT_UNROLL_XLATE:
    case OFPACT_CT_CLEAR:
    case OFPACT_DEBUG_RECIRC:
    case OFPACT_DEBUG_SLOW:
    case OFPACT_METER:
    case OFPACT_CLEAR_ACTIONS:
    case OFPACT_WRITE_METADATA:
    case OFPACT_GOTO_TABLE:
    case OFPACT_NAT:
    case OFPACT_ENCAP:
    case OFPACT_DECAP:
    case OFPACT_DEC_NSH_TTL:
    case OFPACT_CHECK_PKT_LARGER:
    case OFPACT_DELETE_FIELD:
        return ofpact_next(ofpact);

    case OFPACT_CLONE:
        return ofpact_get_CLONE(ofpact)->actions;

    case OFPACT_CT:
        return ofpact_get_CT(ofpact)->actions;

    case OFPACT_WRITE_ACTIONS:
        return ofpact_get_WRITE_ACTIONS(ofpact)->actions;
    }

    OVS_NOT_REACHED();
}


enum ovs_instruction_type
ovs_instruction_type_from_ofpact_type(enum ofpact_type type,
                                      enum ofp_version version)
{
    switch (type) {
    case OFPACT_METER:
        return (version >= OFP15_VERSION
                ? OVSINST_OFPIT11_APPLY_ACTIONS
                : OVSINST_OFPIT13_METER);
    case OFPACT_CLEAR_ACTIONS:
        return OVSINST_OFPIT11_CLEAR_ACTIONS;
    case OFPACT_WRITE_ACTIONS:
        return OVSINST_OFPIT11_WRITE_ACTIONS;
    case OFPACT_WRITE_METADATA:
        return OVSINST_OFPIT11_WRITE_METADATA;
    case OFPACT_GOTO_TABLE:
        return OVSINST_OFPIT11_GOTO_TABLE;
    case OFPACT_OUTPUT:
    case OFPACT_GROUP:
    case OFPACT_CLONE:
    case OFPACT_CONTROLLER:
    case OFPACT_ENQUEUE:
    case OFPACT_OUTPUT_REG:
    case OFPACT_OUTPUT_TRUNC:
    case OFPACT_BUNDLE:
    case OFPACT_SET_VLAN_VID:
    case OFPACT_SET_VLAN_PCP:
    case OFPACT_STRIP_VLAN:
    case OFPACT_PUSH_VLAN:
    case OFPACT_SET_ETH_SRC:
    case OFPACT_SET_ETH_DST:
    case OFPACT_SET_IPV4_SRC:
    case OFPACT_SET_IPV4_DST:
    case OFPACT_SET_IP_DSCP:
    case OFPACT_SET_IP_ECN:
    case OFPACT_SET_IP_TTL:
    case OFPACT_SET_L4_SRC_PORT:
    case OFPACT_SET_L4_DST_PORT:
    case OFPACT_REG_MOVE:
    case OFPACT_SET_FIELD:
    case OFPACT_STACK_PUSH:
    case OFPACT_STACK_POP:
    case OFPACT_DEC_TTL:
    case OFPACT_SET_MPLS_LABEL:
    case OFPACT_SET_MPLS_TC:
    case OFPACT_SET_MPLS_TTL:
    case OFPACT_DEC_MPLS_TTL:
    case OFPACT_PUSH_MPLS:
    case OFPACT_POP_MPLS:
    case OFPACT_SET_TUNNEL:
    case OFPACT_SET_QUEUE:
    case OFPACT_POP_QUEUE:
    case OFPACT_FIN_TIMEOUT:
    case OFPACT_RESUBMIT:
    case OFPACT_LEARN:
    case OFPACT_CONJUNCTION:
    case OFPACT_MULTIPATH:
    case OFPACT_NOTE:
    case OFPACT_EXIT:
    case OFPACT_UNROLL_XLATE:
    case OFPACT_SAMPLE:
    case OFPACT_DEBUG_RECIRC:
    case OFPACT_DEBUG_SLOW:
    case OFPACT_CT:
    case OFPACT_CT_CLEAR:
    case OFPACT_NAT:
    case OFPACT_ENCAP:
    case OFPACT_DECAP:
    case OFPACT_DEC_NSH_TTL:
    case OFPACT_CHECK_PKT_LARGER:
    case OFPACT_DELETE_FIELD:
    default:
        return OVSINST_OFPIT11_APPLY_ACTIONS;
    }
}

/* Returns true if 'action' outputs to 'port', false otherwise. */
static bool
ofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)
{
    switch (ofpact->type) {
    case OFPACT_OUTPUT:
        return ofpact_get_OUTPUT(ofpact)->port == port;
    case OFPACT_ENQUEUE:
        return ofpact_get_ENQUEUE(ofpact)->port == port;
    case OFPACT_CONTROLLER:
        return port == OFPP_CONTROLLER;

    case OFPACT_OUTPUT_REG:
    case OFPACT_OUTPUT_TRUNC:
    case OFPACT_BUNDLE:
    case OFPACT_SET_VLAN_VID:
    case OFPACT_SET_VLAN_PCP:
    case OFPACT_STRIP_VLAN:
    case OFPACT_PUSH_VLAN:
    case OFPACT_SET_ETH_SRC:
    case OFPACT_SET_ETH_DST:
    case OFPACT_SET_IPV4_SRC:
    case OFPACT_SET_IPV4_DST:
    case OFPACT_SET_IP_DSCP:
    case OFPACT_SET_IP_ECN:
    case OFPACT_SET_IP_TTL:
    case OFPACT_SET_L4_SRC_PORT:
    case OFPACT_SET_L4_DST_PORT:
    case OFPACT_REG_MOVE:
    case OFPACT_SET_FIELD:
    case OFPACT_STACK_PUSH:
    case OFPACT_STACK_POP:
    case OFPACT_DEC_TTL:
    case OFPACT_SET_MPLS_LABEL:
    case OFPACT_SET_MPLS_TC:
    case OFPACT_SET_MPLS_TTL:
    case OFPACT_DEC_MPLS_TTL:
    case OFPACT_SET_TUNNEL:
    case OFPACT_WRITE_METADATA:
    case OFPACT_SET_QUEUE:
    case OFPACT_POP_QUEUE:
    case OFPACT_FIN_TIMEOUT:
    case OFPACT_RESUBMIT:
    case OFPACT_LEARN:
    case OFPACT_CONJUNCTION:
    case OFPACT_MULTIPATH:
    case OFPACT_NOTE:
    case OFPACT_EXIT:
    case OFPACT_UNROLL_XLATE:
    case OFPACT_PUSH_MPLS:
    case OFPACT_POP_MPLS:
    case OFPACT_SAMPLE:
    case OFPACT_CLEAR_ACTIONS:
    case OFPACT_CLONE:
    case OFPACT_WRITE_ACTIONS:
    case OFPACT_GOTO_TABLE:
    case OFPACT_METER:
    case OFPACT_GROUP:
    case OFPACT_DEBUG_RECIRC:
    case OFPACT_DEBUG_SLOW:
    case OFPACT_CT:
    case OFPACT_CT_CLEAR:
    case OFPACT_NAT:
    case OFPACT_ENCAP:
    case OFPACT_DECAP:
    case OFPACT_DEC_NSH_TTL:
    case OFPACT_CHECK_PKT_LARGER:
    case OFPACT_DELETE_FIELD:
    default:
        return false;
    }
}

/* True if an action is allowed in the action set.
 * False otherwise. */
static bool
ofpact_is_allowed_in_actions_set(const struct ofpact *a)
{
    return action_set_classify(a) != ACTION_SLOT_INVALID;
}
static enum action_set_class
action_set_classify(const struct ofpact *a)
{
    switch (a->type) {
#define SLOT(OFPACT) case OFPACT: return ACTION_SLOT_##OFPACT;
        ACTION_SET_ORDER
#undef SLOT

#define FINAL(OFPACT) case OFPACT: return ACTION_SLOT_##OFPACT;
        ACTION_SET_FINAL_PRIORITY
#undef FINAL

    case OFPACT_SET_FIELD:
    case OFPACT_REG_MOVE:
    case OFPACT_SET_ETH_DST:
    case OFPACT_SET_ETH_SRC:
    case OFPACT_SET_IP_DSCP:
    case OFPACT_SET_IP_ECN:
    case OFPACT_SET_IP_TTL:
    case OFPACT_SET_IPV4_DST:
    case OFPACT_SET_IPV4_SRC:
    case OFPACT_SET_L4_DST_PORT:
    case OFPACT_SET_L4_SRC_PORT:
    case OFPACT_SET_MPLS_LABEL:
    case OFPACT_SET_MPLS_TC:
    case OFPACT_SET_MPLS_TTL:
    case OFPACT_SET_QUEUE:
    case OFPACT_SET_TUNNEL:
    case OFPACT_SET_VLAN_PCP:
    case OFPACT_SET_VLAN_VID:
        return ACTION_SLOT_SET_OR_MOVE;

    case OFPACT_BUNDLE:
    case OFPACT_CLEAR_ACTIONS:
    case OFPACT_CLONE:
    case OFPACT_NAT:
    case OFPACT_CONTROLLER:
    case OFPACT_ENQUEUE:
    case OFPACT_EXIT:
    case OFPACT_UNROLL_XLATE:
    case OFPACT_FIN_TIMEOUT:
    case OFPACT_GOTO_TABLE:
    case OFPACT_LEARN:
    case OFPACT_CONJUNCTION:
    case OFPACT_METER:
    case OFPACT_MULTIPATH:
    case OFPACT_NOTE:
    case OFPACT_OUTPUT_REG:
    case OFPACT_OUTPUT_TRUNC:
    case OFPACT_POP_QUEUE:
    case OFPACT_SAMPLE:
    case OFPACT_STACK_POP:
    case OFPACT_STACK_PUSH:
    case OFPACT_WRITE_ACTIONS:
    case OFPACT_WRITE_METADATA:
    case OFPACT_DEBUG_RECIRC:
    case OFPACT_DEBUG_SLOW:
    case OFPACT_CHECK_PKT_LARGER:
    case OFPACT_DELETE_FIELD:
        return ACTION_SLOT_INVALID;

    default:
        OVS_NOT_REACHED();
    }
}


////////////////////7. 处理upcall，slow path处理完毕后，将flow放入fast path



////////////////////8. 用户态和内核态netlink互通



////////////////////9. 命令行ovs-ofctl修改


