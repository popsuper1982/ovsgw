openvswitch add action details

6.添加一个operation和action

1.定义openflow action
所有action定义在lib/ofp-actions.c

在enum ofp_raw_action_type {中添加

    /* OF1.0+(29): uint32_t. */
OFPAT_RAW_PROBDROP,

注释非常重要，说明了协议版本，序号，构造openflow消息所需参数
有些函数头是根据协议版本、代码和操作所需的参数类型自动生成的。 后面的序号是独一无二的，不能在同一协议版本中出现两个一样的序号

配置了上述后，编译过程会自动生成函数

put_OFPAT_PROBDROP: 根据 uint32_t构造出openflow消息

对于gateway的操作，我们新增两个action

    /* OF1.0+(28): struct ofp_action_config_gw. */
    OFPAT_RAW_CONFIG_GW,

    /* OF1.0+(29): struct ofp_action_handle_gw. */
    OFPAT_RAW_HANDLE_GW,

所以上述我们的两个定义也会生成两个函数
put_OFPAT_CONFIG_GW 根据ofp_action_config_gw构造出openflow消息
put_OFPAT_HANDLE_GW 根据ofp_action_handle_gw构造出openflow消息

接下来定义struct ofp_action_config_gw和struct ofp_action_handle_gw

我们添加两个struct的定义，并且设置cache对齐

struct ofp_action_config_gw {
    ovs_be16 type;
    ovs_be16 len;
    uint32_t param1;
    ovs_be32 param2;
    struct eth_addr param3;
    uint32_t param4;
    ovs_be32 param5;
    struct eth_addr param6;
    uint32_t param7;
    ovs_be32 param8;
    struct eth_addr param9;
    uint8_t pad[2];
};
OFP_ASSERT(sizeof(struct ofp_action_config_gw) == 48);

struct ofp_action_handle_gw {
    ovs_be16 type;
    ovs_be16 len;
    uint32_t pipeline1;
    uint32_t pipeline2;
    uint32_t pipeline3;
    uint32_t pipeline4;
    uint32_t pipeline5;
};
OFP_ASSERT(sizeof(struct ofp_action_handle_gw) == 24);

2.定义openvswitch action
所有action定义在include/openvswitch/ofp-actions.h中

OFPACT(PROBDROP,        ofpact_probdrop,    ofpact, "probdrop")

还需要定义两个参数的结构

/* ..., after "struct ofpact_decap { ... }" */

/* OFPACT_PROBDROP.
 *
 * Used for OFPAT_PROBDROP */
struct ofpact_probdrop {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint32_t prob;           /* Uint probability, "covers" 0->1 range. */
    );
    uint8_t data[];
};

定义openvswitch action会生成一些列函数

ofpact_put_PROBDROP: 将ofpbuf转化为struct ofpact_probdrop: openflow消息转化openvswitch action

ofpact_get_PROBDROP: 从ofpact获取为struct ofpact_probdrop: 获取openvswitch action


对于我们来说，添加这两个

    OFPACT(CONFIG_GW,       ofpact_config_gw,   ofpact, "config_gw")  \
    OFPACT(HANDLE_GW,       ofpact_handle_gw,   ofpact, "handle_gw") \

这里相当于定义两个openvswitch action
OFPACT_CONFIG_GW
OFPACT_HANDLE_GW

还需要定义两个参数的结构

struct ofpact_config_gw {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint32_t param1;
        ovs_be32 param2;
        struct eth_addr param3;
        uint32_t param4;
        ovs_be32 param5;
        struct eth_addr param6;
        uint32_t param7;
        ovs_be32 param8;
        struct eth_addr param9;
    );
};

struct ofpact_handle_gw {
    OFPACT_PADDED_MEMBERS(
        struct ofpact ofpact;
        uint32_t pipeline1;
        uint32_t pipeline2;
        uint32_t pipeline3;
        uint32_t pipeline4;
        uint32_t pipeline5;
    );
};

定义openvswitch action会生成一些列函数

ofpact_put_CONFIG_GW
ofpact_get_CONFIG_GW
ofpact_put_HANDLE_GW
ofpact_get_HANDLE_GW

3.openflow action与openvswitch action转化

openflow action 与openvswitch action 有对应关系在ofpact_map中, 可以理解为多个版本openflow对应一个openvswitch action

我们修改static const struct ofpact_map * get_ofpact_map(enum ofp_version version)

做了一个映射OFPACT_CONFIG_GW是openvswitch的action，28是openflow的action

static const struct ofpact_map *
get_ofpact_map(enum ofp_version version)
{
    /* OpenFlow 1.0 actions. */
    static const struct ofpact_map of10[] = {
        { OFPACT_OUTPUT, 0 },
        { OFPACT_SET_VLAN_VID, 1 },
        { OFPACT_SET_VLAN_PCP, 2 },
        { OFPACT_STRIP_VLAN, 3 },
        { OFPACT_SET_ETH_SRC, 4 },
        { OFPACT_SET_ETH_DST, 5 },
        { OFPACT_SET_IPV4_SRC, 6 },
        { OFPACT_SET_IPV4_DST, 7 },
        { OFPACT_SET_IP_DSCP, 8 },
        { OFPACT_SET_L4_SRC_PORT, 9 },
        { OFPACT_SET_L4_DST_PORT, 10 },
        { OFPACT_ENQUEUE, 11 },
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    /* OpenFlow 1.1 actions. */
    static const struct ofpact_map of11[] = {
        { OFPACT_OUTPUT, 0 },
        { OFPACT_SET_VLAN_VID, 1 },
        { OFPACT_SET_VLAN_PCP, 2 },
        { OFPACT_SET_ETH_SRC, 3 },
        { OFPACT_SET_ETH_DST, 4 },
        { OFPACT_SET_IPV4_SRC, 5 },
        { OFPACT_SET_IPV4_DST, 6 },
        { OFPACT_SET_IP_DSCP, 7 },
        { OFPACT_SET_IP_ECN, 8 },
        { OFPACT_SET_L4_SRC_PORT, 9 },
        { OFPACT_SET_L4_DST_PORT, 10 },
        /* OFPAT_COPY_TTL_OUT (11) not supported. */
        /* OFPAT_COPY_TTL_IN (12) not supported. */
        { OFPACT_SET_MPLS_LABEL, 13 },
        { OFPACT_SET_MPLS_TC, 14 },
        { OFPACT_SET_MPLS_TTL, 15 },
        { OFPACT_DEC_MPLS_TTL, 16 },
        { OFPACT_PUSH_VLAN, 17 },
        { OFPACT_STRIP_VLAN, 18 },
        { OFPACT_PUSH_MPLS, 19 },
        { OFPACT_POP_MPLS, 20 },
        { OFPACT_SET_QUEUE, 21 },
        { OFPACT_GROUP, 22 },
        { OFPACT_SET_IP_TTL, 23 },
        { OFPACT_DEC_TTL, 24 },
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    /* OpenFlow 1.2, 1.3, and 1.4 actions. */
    static const struct ofpact_map of12[] = {
        { OFPACT_OUTPUT, 0 },
        /* OFPAT_COPY_TTL_OUT (11) not supported. */
        /* OFPAT_COPY_TTL_IN (12) not supported. */
        { OFPACT_SET_MPLS_TTL, 15 },
        { OFPACT_DEC_MPLS_TTL, 16 },
        { OFPACT_PUSH_VLAN, 17 },
        { OFPACT_STRIP_VLAN, 18 },
        { OFPACT_PUSH_MPLS, 19 },
        { OFPACT_POP_MPLS, 20 },
        { OFPACT_SET_QUEUE, 21 },
        { OFPACT_GROUP, 22 },
        { OFPACT_SET_IP_TTL, 23 },
        { OFPACT_DEC_TTL, 24 },
        { OFPACT_SET_FIELD, 25 },
        /* OF1.3+ OFPAT_PUSH_PBB (26) not supported. */
        /* OF1.3+ OFPAT_POP_PBB (27) not supported. */
        { OFPACT_CONFIG_GW, 28},
        { OFPACT_HANDLE_GW, 29},
        { 0, -1 },
    };

    switch (version) {
    case OFP10_VERSION:
        return of10;

    case OFP11_VERSION:
        return of11;

    case OFP12_VERSION:
    case OFP13_VERSION:
    case OFP14_VERSION:
    case OFP15_VERSION:
    default:
        return of12;
    }
}

openflow action与openvswitch action转化需要实现以下几个函数

ofpact_decode---->decode_OFPAT_RAW_PROBDROP: 解openflow消息生成openvswitch action
ofpact_encode---->encode_PROBDROP: 从ofpact_type构造openflow消息
ofpact_parse---->parse_PROBDROP: 从字符串解析构造openvswitch action
ofpact_format---->format_PROBDROP: 将openvswitch action转化为string
ofpact_format---->check_PROBDROP:校验openvswitch action

/* 在 check_PROBDROP 函数后面添加*/

/* Okay, the new stuff! */

/* Encoding the action packet to put on the wire. */
static void
encode_PROBDROP(const struct ofpact_probdrop *prob,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out)
{
    uint32_t p = prob->prob;

    put_OFPAT_PROBDROP(out, p);
}

/* Reversing the process. */
static enum ofperr
decode_OFPAT_RAW_PROBDROP(uint32_t prob,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
    struct ofpact_probdrop *op;
    op = ofpact_put_PROBDROP(out);
    op->prob = prob;

    return 0;
}

/* Helper for below. */
static char * OVS_WARN_UNUSED_RESULT
parse_prob(char *arg, struct ofpbuf *ofpacts)
{
    struct ofpact_probdrop *probdrop;
    uint32_t prob;
    char *error;

    error = str_to_u32(arg, &prob);
    if (error) return error;

    probdrop = ofpact_put_PROBDROP(ofpacts);
    probdrop->prob = prob;
    return NULL;
}

/* Go from string-formatted args into an action struct.
e.g. ovs-ofctl add-flow ... actions=probdrop:3000000000,output:"s2-eth0"
*/
static char * OVS_WARN_UNUSED_RESULT
parse_PROBDROP(char *arg, const struct ofpact_parse_params *pp)
{
    return parse_prob(arg, pp->ofpacts);
}

/* Used when printing info to console. */
static void
format_PROBDROP(const struct ofpact_probdrop *a,
                const struct ofpact_format_params *fp)
{
    /* Feel free to use e.g. colors.param,
    colors.end around parameter names */
    ds_put_format(fp->s, "probdrop:%"PRIu32, a->prob);
}

/* ... */

static enum ofperr
check_PROBDROP(const struct ofpact_probdrop *a OVS_UNUSED,
                const struct ofpact_check_params *cp OVS_UNUSED)
{
    /* My method needs no checking. Probably. */
    return 0;
}

s表示短、l表示长；
ntohs =net to host short int 16位
htons=host to net short int 16位
ntohl =net to host long int 32位
htonl=host to net long int 32位

我们写 /* OF1.0+(28): struct ofp_action_config_gw. */ OFPAT_RAW_CONFIG_GW 对应的decode, encode, parse, format

static enum ofperr
decode_OFPAT_RAW_CONFIG_GW(const struct ofp_action_config_gw *a,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
    struct ofpact_config_gw *config_gw;

    config_gw = ofpact_put_CONFIG_GW(out);

    //may do ntohs htons ntohl htonl
    config_gw->param1 = a->param1;
    config_gw->param2 = a->param2;
    config_gw->param3 = a->param3;
    config_gw->param4 = a->param4;
    config_gw->param5 = a->param5;
    config_gw->param6 = a->param6;
    config_gw->param7 = a->param7;
    config_gw->param8 = a->param8;
    config_gw->param9 = a->param9;
}


static void
encode_CONFIG_GW(const struct ofpact_config_gw *config_gw,
                  enum ofp_version ofp_version, struct ofpbuf *out)
{

    struct ofp_action_config_gw *ofp_config_gw;

    ofp_config_gw = put_OFPAT_CONFIG_GW(out);

    //may do ntohs htons ntohl htonl
    ofp_config_gw->param1 = config_gw->param1;
    ofp_config_gw->param2 = config_gw->param2;
    ofp_config_gw->param3 = config_gw->param3;
    ofp_config_gw->param4 = config_gw->param4;
    ofp_config_gw->param5 = config_gw->param5;
    ofp_config_gw->param6 = config_gw->param6;
    ofp_config_gw->param7 = config_gw->param7;
    ofp_config_gw->param8 = config_gw->param8;
    ofp_config_gw->param9 = config_gw->param9;
}

static char * OVS_WARN_UNUSED_RESULT
parse_CONFIG_GW(const char *arg, const struct ofpact_parse_params *pp)
{
    struct ofpbuf *ofpacts;
    struct ofpact_config_gw *config_gw;
    char *name, *value;
    struct eth_addr ethaddr;
    char *error;

    ofpacts = pp->ofpacts;
    config_gw = ofpact_put_CONFIG_GW(ofpacts);

    while (ofputil_parse_key_value(&arg, &name, &value)) {
        if (!strcmp(name, "param1")) {
            config_gw->param1 = atoi(value);
        } else if (!strcmp(name, "param2")) {
            config_gw->param2 = atoi(value);
        } else if (!strcmp(name, "param3")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param3 = ethaddr;
        } else if (!strcmp(name, "param4")) {
            config_gw->param4 = atoi(value);
        } else if (!strcmp(name, "param5")) {
            config_gw->param5 = atoi(value);
        } else if (!strcmp(name, "param6")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param6 = ethaddr;
        } else if (!strcmp(name, "param7")) {
            config_gw->param7 = atoi(value);
        } else if (!strcmp(name, "param8")) {
            config_gw->param8 = atoi(value);
        } else if (!strcmp(name, "param9")) {
            error = str_to_mac(value, &ethaddr);
            if (error) {
                return error;
            }
            config_gw->param9 = ethaddr;
        } 
    }

    return NULL;
}

static void
format_CONFIG_GW(const struct ofpact_config_gw *a, const struct ofpact_format_params *fp)
{
    struct ds *s;

    s = fp->s;

    ds_put_format(s, "config_gw(");
    if (a->param1 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param2 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param3 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }
    if (a->param4 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param5 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param6 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }
    if (a->param7 != 0) {
        ds_put_format(s, "param1=%"PRIu32, a->param1);
    }
    if (a->param8 != 0) {
        ds_put_format(s, ",param2=%"PRIx32, ntohl(a->param2));
    }
    if (a->param9 != 0) {
        ds_put_format(s, ",param3=%"ETH_ADDR_FMT, ETH_ADDR_ARGS(a->param3));
    }

    ds_put_format(s, ")");
}

我们写 /* OF1.0+(29): struct ofp_action_handle_gw. */ OFPAT_RAW_HANDLE_GW 对应的decode, encode, parse, format

static enum ofperr
decode_OFPAT_RAW_HANDLE_GW(const struct ofp_action_handle_gw *a,
                            enum ofp_version ofp_version OVS_UNUSED,
                            struct ofpbuf *out)
{
    struct ofpact_handle_gw *handle_gw;

    handle_gw = ofpact_put_CONFIG_GW(out);

    //may do ntohs htons ntohl htonl
    handle_gw->pipeline1 = a->pipeline1;
    handle_gw->pipeline2 = a->pipeline2;
    handle_gw->pipeline3 = a->pipeline3;
    handle_gw->pipeline4 = a->pipeline4;
    handle_gw->pipeline5 = a->pipeline5;
}


static void
encode_HANDLE_GW(const struct ofpact_handle_gw *handle_gw,
                  enum ofp_version ofp_version, struct ofpbuf *out)
{

    struct ofp_action_handle_gw *ofp_handle_gw;

    ofp_handle_gw = put_OFPAT_HANDLE_GW(out);

    //may do ntohs htons ntohl htonl
    ofp_handle_gw->pipeline1 = handle_gw->pipeline1;
    ofp_handle_gw->pipeline2 = handle_gw->pipeline2;
    ofp_handle_gw->pipeline3 = handle_gw->pipeline3;
    ofp_handle_gw->pipeline4 = handle_gw->pipeline4;
    ofp_handle_gw->pipeline5 = handle_gw->pipeline5;
}

static char * OVS_WARN_UNUSED_RESULT
parse_HANDLE_GW(const char *arg, const struct ofpact_parse_params *pp)
{
    struct ofpbuf *ofpacts;
    struct ofpact_handle_gw *handle_gw;
    char *name, *value;
    struct eth_addr ethaddr;
    char *error;

    ofpacts = pp->ofpacts;
    handle_gw = ofpact_put_HANDLE_GW(ofpacts);

    while (ofputil_parse_key_value(&arg, &name, &value)) {
        if (!strcmp(name, "pipeline1")) {
            handle_gw->pipeline1 = atoi(value);
        } else if (!strcmp(name, "pipeline2")) {
            handle_gw->pipeline2 = atoi(value);
        } else if (!strcmp(name, "pipeline3")) {
            handle_gw->pipeline3 = atoi(value);
        } else if (!strcmp(name, "pipeline4")) {
            handle_gw->pipeline4 = atoi(value);
        } else if (!strcmp(name, "pipeline5")) {
            handle_gw->pipeline5 = atoi(value);
        }
    }

    return NULL;
}

static void
format_HANDLE_GW(const struct ofpact_handle_gw *a, const struct ofpact_format_params *fp)
{
    struct ds *s;

    s = fp->s;

    ds_put_format(s, "handle_gw(");
    if (a->pipeline1 != 0) {
        ds_put_format(s, "pipeline1=%"PRIu32, a->pipeline1);
    }
    if (a->pipeline2 != 0) {
        ds_put_format(s, ",pipeline2=%"PRIx32, ntohl(a->pipeline2));
    }
    if (a->pipeline3 != 0) {
        ds_put_format(s, ",pipeline3=%"PRIx32, ETH_ADDR_ARGS(a->pipeline3));
    }
    if (a->pipeline4 != 0) {
        ds_put_format(s, "pipeline4=%"PRIu32, a->pipeline4);
    }
    if (a->pipeline5 != 0) {
        ds_put_format(s, ",pipeline5=%"PRIx32, ntohl(a->pipeline5));
    }
    ds_put_format(s, ")");
}

4.数据面action的定义

action是实现在这里datapath\linux\compat\include\linux\openvswitch.h

enum ovs_action_attr {
    OVS_ACTION_ATTR_UNSPEC,
    OVS_ACTION_ATTR_OUTPUT,       /* u32 port number. */
    OVS_ACTION_ATTR_USERSPACE,    /* Nested OVS_USERSPACE_ATTR_*. */
    OVS_ACTION_ATTR_SET,          /* One nested OVS_KEY_ATTR_*. */
    OVS_ACTION_ATTR_PUSH_VLAN,    /* struct ovs_action_push_vlan. */
    OVS_ACTION_ATTR_POP_VLAN,     /* No argument. */
    OVS_ACTION_ATTR_SAMPLE,       /* Nested OVS_SAMPLE_ATTR_*. */
    OVS_ACTION_ATTR_RECIRC,       /* u32 recirc_id. */
    OVS_ACTION_ATTR_HASH,         /* struct ovs_action_hash. */
    OVS_ACTION_ATTR_PUSH_MPLS,    /* struct ovs_action_push_mpls. */
    OVS_ACTION_ATTR_POP_MPLS,     /* __be16 ethertype. */
    OVS_ACTION_ATTR_SET_MASKED,   /* One nested OVS_KEY_ATTR_* including
                       * data immediately followed by a mask.
                       * The data must be zero for the unmasked
                       * bits. */
    OVS_ACTION_ATTR_CT,           /* Nested OVS_CT_ATTR_* . */
    OVS_ACTION_ATTR_TRUNC,        /* u32 struct ovs_action_trunc. */
    OVS_ACTION_ATTR_PUSH_ETH,     /* struct ovs_action_push_eth. */
    OVS_ACTION_ATTR_POP_ETH,      /* No argument. */
    OVS_ACTION_ATTR_CT_CLEAR,     /* No argument. */
    OVS_ACTION_ATTR_PUSH_NSH,     /* Nested OVS_NSH_KEY_ATTR_*. */
    OVS_ACTION_ATTR_POP_NSH,      /* No argument. */
    OVS_ACTION_ATTR_METER,        /* u32 meter number. */
    OVS_ACTION_ATTR_CLONE,        /* Nested OVS_CLONE_ATTR_*.  */
    OVS_ACTION_ATTR_CHECK_PKT_LEN, /* Nested OVS_CHECK_PKT_LEN_ATTR_*. */
    OVS_ACTION_ATTR_CONFIG_GW = 28,
    OVS_ACTION_ATTR_HANDLE_GW = 29,

#ifndef __KERNEL__
    OVS_ACTION_ATTR_TUNNEL_PUSH,   /* struct ovs_action_push_tnl*/
    OVS_ACTION_ATTR_TUNNEL_POP,    /* u32 port number. */
    OVS_ACTION_ATTR_DROP,          /* u32 xlate_error. */
    OVS_ACTION_ATTR_LB_OUTPUT,     /* u32 bond-id. */
#endif
    __OVS_ACTION_ATTR_MAX,        /* Nothing past this will be accepted
                       * from userspace. */

#ifdef __KERNEL__
    OVS_ACTION_ATTR_SET_TO_MASKED, /* Kernel module internal masked
                    * set action converted from
                    * OVS_ACTION_ATTR_SET. */
#endif
};

在datapath/linux/compat/include/linux/openvswitch.h:中添加：

enum ovs_action_attr {
    /* ... */

    /*
    * after #ifndef __KERNEL__ ... #endif.
    * the equals is thus ABSOLUTELY NECESSARY
    */

    OVS_ACTION_ATTR_PROBDROP = 23, /* unit32_t, prob in [0,2^32 -1] */

    __OVS_ACTION_ATTR_MAX, /* Nothing past this will be accepted
                            * from userspace. */

    /* ... */

}

OVS_ACTION_ATTR_PROBDROP = 23 如果我们不为该枚举条目指定显式值，则内核和用户区部分 ovs-vswitchd将对新操作使用不同的代码（这里不加会出错）

5.upcall的处理过程中从openvswitch action到数据面action的转换

/* Put this with the other "compose" functions. */
static void
compose_probdrop_action(struct xlate_ctx *ctx, struct ofpact_probdrop *op)
{
    uint32_t prob = op->prob;

    nl_msg_put_u32(ctx->odp_actions, OVS_ACTION_ATTR_PROBDROP, prob);
}

/* ... */

static void
do_xlate_actions( /* ... */ )
{
    switch (a->type) {
    /* ... */

    case OFPACT_PROBDROP:
        compose_probdrop_action(ctx, ofpact_get_PROBDROP(a));
        break;
    }
}
/* ... */

/* No action can undo the packet drop: reflect this. */
static bool
reversible_actions(const struct ofpact *ofpacts, size_t ofpacts_len)
{
    const struct ofpact *a;

    OFPACT_FOR_EACH (a, ofpacts, ofpacts_len) {
        switch (a->type) {
        /*... */
        case OFPACT_PROBDROP:
            return false;
        }
    }
    return true;
}

/* ... */

/* PROBDROP likely doesn't require explicit thawing. */
static void
freeze_unroll_actions( /* ... */ )
{
    /* ... */
    switch (a->type) {
        case OFPACT_PROBDROP:
            /* These may not generate PACKET INs. */
            break;
    }
}

/* ... */

/* Naturally, don't need to recirculate since we don't change packets. */
static void
recirc_for_mpls(const struct ofpact *a, struct xlate_ctx *ctx)
{
    /* ... */

    switch (a->type) {
    case OFPACT_PROBDROP:
    default:
        break;
    }
}

在内核中
static int __ovs_nla_copy_actions( /*...*/ )
{
    /* ... */
    static const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {
        /* ... */
        [OVS_ACTION_ATTR_PROBDROP] = sizeof(u32),
    };
    /* ... */

    /* Be careful here, your compiler may not catch this one
    * even with -Werror */
    switch (type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        /* Finalest sanity checks in the kernel. */
        break;
    /* ... */
    }
    /* ... */
}

我们再参考do_xlate_actions中
        case OFPACT_PUSH_MPLS:
            compose_mpls_push_action(ctx, ofpact_get_PUSH_MPLS(a));
            break;

static void
compose_mpls_push_action(struct xlate_ctx *ctx, struct ofpact_push_mpls *mpls)
{
    struct flow *flow = &ctx->xin->flow;
    int n;

    ovs_assert(eth_type_mpls(mpls->ethertype));

    n = flow_count_mpls_labels(flow, ctx->wc);
    if (!n) {
        xlate_commit_actions(ctx);
    } else if (n >= FLOW_MAX_MPLS_LABELS) {
        if (ctx->xin->packet != NULL) {
            xlate_report_error(ctx, "dropping packet on which an MPLS push "
                               "action can't be performed as it would have "
                               "more MPLS LSEs than the %d supported.",
                               FLOW_MAX_MPLS_LABELS);
        }
        ctx->error = XLATE_TOO_MANY_MPLS_LABELS;
        return;
    }

    /* Update flow's MPLS stack, and clear L3/4 fields to mark them invalid. */
    flow_push_mpls(flow, n, mpls->ethertype, ctx->wc, true);
}

xlate_commit_actions->commit_mpls_action

/* Wildcarding already done at action translation time. */
static void
commit_mpls_action(const struct flow *flow, struct flow *base,
                   struct ofpbuf *odp_actions)
{
    int base_n = flow_count_mpls_labels(base, NULL);
    int flow_n = flow_count_mpls_labels(flow, NULL);
    int common_n = flow_count_common_mpls_labels(flow, flow_n, base, base_n,
                                                 NULL);

    while (base_n > common_n) {
        if (base_n - 1 == common_n && flow_n > common_n) {
            /* If there is only one more LSE in base than there are common
             * between base and flow; and flow has at least one more LSE than
             * is common then the topmost LSE of base may be updated using
             * set */
            struct ovs_key_mpls mpls_key;

            mpls_key.mpls_lse = flow->mpls_lse[flow_n - base_n];
            commit_set_action(odp_actions, OVS_KEY_ATTR_MPLS,
                              &mpls_key, sizeof mpls_key);
            flow_set_mpls_lse(base, 0, mpls_key.mpls_lse);
            common_n++;
        } else {
            /* Otherwise, if there more LSEs in base than are common between
             * base and flow then pop the topmost one. */
            ovs_be16 dl_type;
            /* If all the LSEs are to be popped and this is not the outermost
             * LSE then use ETH_TYPE_MPLS as the ethertype parameter of the
             * POP_MPLS action instead of flow->dl_type.
             *
             * This is because the POP_MPLS action requires its ethertype
             * argument to be an MPLS ethernet type but in this case
             * flow->dl_type will be a non-MPLS ethernet type.
             *
             * When the final POP_MPLS action occurs it use flow->dl_type and
             * the and the resulting packet will have the desired dl_type. */
            if ((!eth_type_mpls(flow->dl_type)) && base_n > 1) {
                dl_type = htons(ETH_TYPE_MPLS);
            } else {
                dl_type = flow->dl_type;
            }
            nl_msg_put_be16(odp_actions, OVS_ACTION_ATTR_POP_MPLS, dl_type);
            ovs_assert(flow_pop_mpls(base, base_n, flow->dl_type, NULL));
            base_n--;
        }
    }

    /* If, after the above popping and setting, there are more LSEs in flow
     * than base then some LSEs need to be pushed. */
    while (base_n < flow_n) {
        struct ovs_action_push_mpls *mpls;

        mpls = nl_msg_put_unspec_zero(odp_actions,
                                      OVS_ACTION_ATTR_PUSH_MPLS,
                                      sizeof *mpls);
        mpls->mpls_ethertype = flow->dl_type;
        mpls->mpls_lse = flow->mpls_lse[flow_n - base_n - 1];
        /* Update base flow's MPLS stack, but do not clear L3.  We need the L3
         * headers if the flow is restored later due to returning from a patch
         * port or group bucket. */
        flow_push_mpls(base, base_n, mpls->mpls_ethertype, NULL, false);
        flow_set_mpls_lse(base, 0, mpls->mpls_lse);
        base_n++;
    }
}

static void
compose_config_gw_action(struct xlate_ctx *ctx, struct ofpact_probdrop *op)
{
    uint32_t prob = op->prob;

    nl_msg_put_u32(ctx->odp_actions, OVS_ACTION_ATTR_CONFIG_GW, prob);
}

static int __ovs_nla_copy_actions(struct net *net, const struct nlattr *attr,
                  const struct sw_flow_key *key,
                  struct sw_flow_actions **sfa,
                  __be16 eth_type, __be16 vlan_tci,
                  u32 mpls_label_count, bool log)
{
    u8 mac_proto = ovs_key_mac_proto(key);
    const struct nlattr *a;
    int rem, err;

    nla_for_each_nested(a, attr, rem) {
        /* Expected argument lengths, (u32)-1 for variable length. */
        static const u32 action_lens[OVS_ACTION_ATTR_MAX + 1] = {
            [OVS_ACTION_ATTR_OUTPUT] = sizeof(u32),
            [OVS_ACTION_ATTR_RECIRC] = sizeof(u32),
            [OVS_ACTION_ATTR_USERSPACE] = (u32)-1,
            [OVS_ACTION_ATTR_PUSH_MPLS] = sizeof(struct ovs_action_push_mpls),
            [OVS_ACTION_ATTR_POP_MPLS] = sizeof(__be16),
            [OVS_ACTION_ATTR_PUSH_VLAN] = sizeof(struct ovs_action_push_vlan),
            [OVS_ACTION_ATTR_POP_VLAN] = 0,
            [OVS_ACTION_ATTR_SET] = (u32)-1,
            [OVS_ACTION_ATTR_SET_MASKED] = (u32)-1,
            [OVS_ACTION_ATTR_SAMPLE] = (u32)-1,
            [OVS_ACTION_ATTR_HASH] = sizeof(struct ovs_action_hash),
            [OVS_ACTION_ATTR_CT] = (u32)-1,
            [OVS_ACTION_ATTR_CT_CLEAR] = 0,
            [OVS_ACTION_ATTR_TRUNC] = sizeof(struct ovs_action_trunc),
            [OVS_ACTION_ATTR_PUSH_ETH] = sizeof(struct ovs_action_push_eth),
            [OVS_ACTION_ATTR_POP_ETH] = 0,
            [OVS_ACTION_ATTR_PUSH_NSH] = (u32)-1,
            [OVS_ACTION_ATTR_POP_NSH] = 0,
            [OVS_ACTION_ATTR_METER] = sizeof(u32),
            [OVS_ACTION_ATTR_CLONE] = (u32)-1,
            [OVS_ACTION_ATTR_CHECK_PKT_LEN] = (u32)-1,
        };
        const struct ovs_action_push_vlan *vlan;
        int type = nla_type(a);
        bool skip_copy;

        if (type > OVS_ACTION_ATTR_MAX ||
            (action_lens[type] != nla_len(a) &&
             action_lens[type] != (u32)-1))
            return -EINVAL;

        skip_copy = false;
        switch (type) {
        case OVS_ACTION_ATTR_UNSPEC:
            return -EINVAL;

        case OVS_ACTION_ATTR_USERSPACE:
            err = validate_userspace(a);
            if (err)
                return err;
            break;

        case OVS_ACTION_ATTR_OUTPUT:
            if (nla_get_u32(a) >= DP_MAX_PORTS)
                return -EINVAL;
            break;

        case OVS_ACTION_ATTR_TRUNC: {
            const struct ovs_action_trunc *trunc = nla_data(a);

            if (trunc->max_len < ETH_HLEN)
                return -EINVAL;
            break;
        }

        case OVS_ACTION_ATTR_HASH: {
            const struct ovs_action_hash *act_hash = nla_data(a);

            switch (act_hash->hash_alg) {
            case OVS_HASH_ALG_L4:
                break;
            default:
                return  -EINVAL;
            }

            break;
        }

        case OVS_ACTION_ATTR_POP_VLAN:
            if (mac_proto != MAC_PROTO_ETHERNET)
                return -EINVAL;
            vlan_tci = htons(0);
            break;

        case OVS_ACTION_ATTR_PUSH_VLAN:
            if (mac_proto != MAC_PROTO_ETHERNET)
                return -EINVAL;
            vlan = nla_data(a);
            if (!eth_type_vlan(vlan->vlan_tpid))
                return -EINVAL;
            if (!(vlan->vlan_tci & htons(VLAN_CFI_MASK)))
                return -EINVAL;
            vlan_tci = vlan->vlan_tci;
            break;

        case OVS_ACTION_ATTR_RECIRC:
            break;

        case OVS_ACTION_ATTR_PUSH_MPLS: {
            const struct ovs_action_push_mpls *mpls = nla_data(a);

            if (!eth_p_mpls(mpls->mpls_ethertype))
                return -EINVAL;
            /* Prohibit push MPLS other than to a white list
             * for packets that have a known tag order.
             */
            if (vlan_tci & htons(VLAN_CFI_MASK) ||
                (eth_type != htons(ETH_P_IP) &&
                 eth_type != htons(ETH_P_IPV6) &&
                 eth_type != htons(ETH_P_ARP) &&
                 eth_type != htons(ETH_P_RARP) &&
                 !eth_p_mpls(eth_type)))
                return -EINVAL;
            eth_type = mpls->mpls_ethertype;
            mpls_label_count++;
            break;
        }

        case OVS_ACTION_ATTR_POP_MPLS: {
            __be16  proto;
            if (vlan_tci & htons(VLAN_CFI_MASK) ||
                !eth_p_mpls(eth_type))
                return -EINVAL;

            /* Disallow subsequent L2.5+ set actions and mpls_pop
             * actions once the last MPLS label in the packet is
             * popped as there is no check here to ensure that
             * the new eth type is valid and thus set actions could
             * write off the end of the packet or otherwise corrupt
             * it.
             *
             * Support for these actions is planned using packet
             * recirculation.
             */
            proto = nla_get_be16(a);
            mpls_label_count--;

            if (!eth_p_mpls(proto) || !mpls_label_count)
                eth_type = htons(0);
            else
                eth_type =  proto;
            break;
        }
        case OVS_ACTION_ATTR_SET:
            err = validate_set(a, key, sfa,
                       &skip_copy, mac_proto, eth_type,
                       false, log);
            if (err)
                return err;
            break;

        case OVS_ACTION_ATTR_SET_MASKED:
            err = validate_set(a, key, sfa,
                       &skip_copy, mac_proto, eth_type,
                       true, log);
            if (err)
                return err;
            break;

        case OVS_ACTION_ATTR_SAMPLE: {
            bool last = nla_is_last(a, rem);

            err = validate_and_copy_sample(net, a, key, sfa,
                               eth_type, vlan_tci,
                               mpls_label_count,
                               log, last);
            if (err)
                return err;
            skip_copy = true;
            break;
        }

        case OVS_ACTION_ATTR_CT:
            err = ovs_ct_copy_action(net, a, key, sfa, log);
            if (err)
                return err;
            skip_copy = true;
            break;

        case OVS_ACTION_ATTR_CT_CLEAR:
            break;

        case OVS_ACTION_ATTR_PUSH_ETH:
            /* Disallow pushing an Ethernet header if one
             * is already present */
            if (mac_proto != MAC_PROTO_NONE)
                return -EINVAL;
            mac_proto = MAC_PROTO_ETHERNET;
            break;

        case OVS_ACTION_ATTR_POP_ETH:
            if (mac_proto != MAC_PROTO_ETHERNET)
                return -EINVAL;
            if (vlan_tci & htons(VLAN_CFI_MASK))
                return -EINVAL;
            mac_proto = MAC_PROTO_NONE;
            break;

        case OVS_ACTION_ATTR_PUSH_NSH:
            if (mac_proto != MAC_PROTO_ETHERNET) {
                u8 next_proto;

                next_proto = tun_p_from_eth_p(eth_type);
                if (!next_proto)
                    return -EINVAL;
            }
            mac_proto = MAC_PROTO_NONE;
            if (!validate_nsh(nla_data(a), false, true, true))
                return -EINVAL;
            break;

        case OVS_ACTION_ATTR_POP_NSH: {
            __be16 inner_proto;

            if (eth_type != htons(ETH_P_NSH))
                return -EINVAL;
            inner_proto = tun_p_to_eth_p(key->nsh.base.np);
            if (!inner_proto)
                return -EINVAL;
            if (key->nsh.base.np == TUN_P_ETHERNET)
                mac_proto = MAC_PROTO_ETHERNET;
            else
                mac_proto = MAC_PROTO_NONE;
            break;
        }

        case OVS_ACTION_ATTR_METER:
            /* Non-existent meters are simply ignored.  */
            break;

        case OVS_ACTION_ATTR_CLONE: {
            bool last = nla_is_last(a, rem);

            err = validate_and_copy_clone(net, a, key, sfa,
                              eth_type, vlan_tci,
                              mpls_label_count,
                              log, last);
            if (err)
                return err;
            skip_copy = true;
            break;
        }

        case OVS_ACTION_ATTR_CHECK_PKT_LEN: {
                        bool last = nla_is_last(a, rem);

                        err = validate_and_copy_check_pkt_len(net, a, key, sfa,
                                                              eth_type,
                                                              vlan_tci, log,
                                  mpls_label_count,
                                                              last);
                        if (err)
                                return err;
                        skip_copy = true;
                        break;
                }

        default:
            OVS_NLERR(log, "Unknown Action type %d", type);
            return -EINVAL;
        }
        if (!skip_copy) {
            err = copy_action(a, sfa, log);
            if (err)
                return err;
        }
    }

    if (rem > 0)
        return -EINVAL;

    return 0;
}

/*
 * struct ovs_action_push_eth - %OVS_ACTION_ATTR_PUSH_ETH action argument.
 * @addresses: Source and destination MAC addresses.
 */
struct ovs_action_push_eth {
    struct ovs_key_ethernet addresses;
};

/**
 * struct ovs_action_push_vlan - %OVS_ACTION_ATTR_PUSH_VLAN action argument.
 * @vlan_tpid: Tag protocol identifier (TPID) to push.
 * @vlan_tci: Tag control identifier (TCI) to push.  The CFI bit must be set
 * (but it will not be set in the 802.1Q header that is pushed).
 *
 * The @vlan_tpid value is typically %ETH_P_8021Q or %ETH_P_8021AD.
 * The only acceptable TPID values are those that the kernel module also parses
 * as 802.1Q or 802.1AD headers, to prevent %OVS_ACTION_ATTR_PUSH_VLAN followed
 * by %OVS_ACTION_ATTR_POP_VLAN from having surprising results.
 */
struct ovs_action_push_vlan {
    __be16 vlan_tpid;   /* 802.1Q or 802.1ad TPID. */
    __be16 vlan_tci;    /* 802.1Q TCI (VLAN ID and priority). */
};
6.内核模式datapath的action的执行的实现

在内核模块中实现action函数，并调用执行，datapath/actions.c

/* Ask for a random number.
   "p" is the amount we should let through, here true means drop,
   false means let it pass on */
static bool prob_drop(uint32_t prob)
{
    /* since we can't use rand() in the kernel */
    return prandom_u32() > prob;　　
}

static int do_execute_actions(/* ... */)
{
    /* ... */
    switch (nla_type(a)) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        /* No need to free, taken care of for us
           This function just reads the attribute to
           know if we should drop. */
        if(prob_drop(nla_get_u32(a)))
        {
            while (rem) {
                a = nla_next(a, &rem);
            }
        }
        break;
    }
    /* ... */
}

7.DPDK模式的action的执行的实现

lib/packets.h：

/* ... */

bool prob_drop(uint32_t prob);

#endif /* packets.h */

lib/packets.c:

/* Ask for a random number.
   "p" is the amount we should let through, here true means drop,
   false means let it pass on */
bool
prob_drop(uint32_t prob)
{
    unsigned int roll_i;
    random_bytes(&roll_i, sizeof(roll_i));
    return roll_i > prob;
}

lib/dpif-netdev.c:

static void
dp_execute_cb( /* ... */ )
{
    /* ... */
    switch ((enum ovs_action_attr)type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        OVS_NOT_REACHED();
    }
}

static bool
requires_datapath_assistance(const struct nlattr *a)
{
    enum ovs_action_attr type = nl_attr_type(a);

    switch (type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        return false;
    /* ... */
    }
}

odp_execute_actions(&aux, packets, should_steal, actions,
                        actions_len, dp_execute_cb);
在这个函数里面，只有requires_datapath_assistance为true，才会调用dp_execute_cb

lib/odp-execute.c

void
odp_execute_actions( /* ... */ )
{
    /* ... */
    switch ((enum ovs_action_attr)type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP: {　　　　
        size_t i;
        const size_t num = dp_packet_batch_size(batch);

        DP_PACKET_BATCH_REFILL_FOR_EACH (i, num, packet, batch) {
            if (!prob_drop(nl_attr_get_u32(a))) {
                dp_packet_batch_refill(batch, packet, i);
            } else {
                dp_packet_delete(packet);
            }
        }
        break;
    }

    }
}


lib/dpif.c:

static void
dpif_execute_helper_cb( /* ... */ )
{
    /* ... */
    switch ((enum ovs_action_attr)type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        OVS_NOT_REACHED();
    }
}

ofproto/ofproto-dpif-ipfix.c:

void
dpif_ipfix_read_actions( /* ... */ )
{
    /* ... */
    switch (type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        /* Again, ignore for now. Not needed. */
        break;
    }
}

ofproto/ofproto-dpif-sflow.c:

void
dpif_sflow_read_actions( /* ... */ )
{
    switch (type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP:
        /* Ignore sFlow for now, unless needed. */
        break;
    }
}

8.命令行ovs-ofctl修改

这里需要添加新的OFPACT_的action

struct ofpact *
ofpact_next_flattened(const struct ofpact *ofpact)
{
    switch (ofpact->type) {
        /* ... */
        case OFPACT_PROBDROP:
            return ofpact_next(ofpact);
    }
    /* ... */
}

/* ... */

enum ovs_instruction_type
ovs_instruction_type_from_ofpact_type(enum ofpact_type type)
{
    switch (type) {
    /* ... */
    case OFPACT_PROBDROP:
    default:
        return OVSINST_OFPIT11_APPLY_ACTIONS;
    /* ... */
    }
}

/* ... */

static bool
ofpact_outputs_to_port(const struct ofpact *ofpact, ofp_port_t port)
{
    switch (ofpact->type) {
    /* ... */
    case OFPACT_PROBDROP:
    default:
        return false;
    }
}

static enum action_set_class
action_set_classify(const struct ofpact a*)
{
    switch (a->type) {
    /* ... */


    /* NEVER */
    /* ... */
    case OFPACT_PROBDROP:
        return ACTION_SLOT_INVALID;

    /* ... */
    }
}

9.命令行dpctl修改

static void
format_odp_action( /* ... */ )
{
    /* ... */
    switch (type) {
    /* ... */

    case OVS_ACTION_ATTR_PROBDROP: 
        ds_put_format(ds, "pdrop(%"PRIu32")", nl_attr_get_u32(a));
        break;

    /* ... */
    }
}

static int
odp_action_len(uint16_t type)
{
    /* ... */

    switch ((enum ovs_action_attr) type) {
    /* ... */
    case OVS_ACTION_ATTR_PROBDROP: return sizeof(uint32_t);
    }
}